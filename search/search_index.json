{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Earth Library","text":"<p> A global reference library for land cover spectra, and tools for working with it. </p> <p> </p> <p>Documentation: earth-chris.github.io/earthlib</p> <p>Source code: earth-chris/earthlib</p>"},{"location":"#introduction","title":"Introduction","text":"<p><code>earthlib</code> is a spectral library and a set of software tools for satellite-base land cover mapping.</p> <p>The library contains several thousand unique spectral endmembers representing green vegetation, soil, non-photosynthetic vegetation, urban materials, and burned materials. The reflectance data cover the visible to the shortwave infrared wavelengths (400-2450 nm) at 10 nm band widths.</p> <p>The software tools (1) resample these data to match the wavelenths of popular satellite and airborne earth observing sensors and (2) run spectral mixture analysis in Google Earth Engine via the <code>earthengine</code> python package.</p> <p>The goal is to quantify spatial and temporal patterns of change in global vegetation cover, as well as patterns of soil cover, burned area, non-photosynthetic vegetation, and impervious surfaces. With <code>earthlib</code>, you can do this using most public satellite data sources.</p>"},{"location":"#installation","title":"Installation","text":"<p>This library can be installed via <code>pip</code>.</p> <pre><code>pip install earthlib\n</code></pre> <p>You can also clone the source repository and install it locally.</p> <pre><code>git clone https://github.com/earth-chris/earthlib.git\ncd earthlib\npip install -e .\n</code></pre>"},{"location":"#developed-by","title":"Developed by","text":"<p>Christopher Anderson</p> <p> </p> <p>This work was supported by the Stanford Center for Conservation Biology and the Natural Capital Project.</p>"},{"location":"introduction/","title":"Spectral Mixture Analysis","text":"<p>The contents of a satellite image pixel are rarely homogeneous. An area 30x30m in size can include buildings, trees, and roads in urban environments; grasses, soils, and char in recently burned landscapes; trees, gaps, and downed logs in forested areas. These patterns all affect the reflectance patterns measured by satellites, and it's important to be able to estimate the sub-pixel abundances of each of these land cover types.</p> <p></p> <p>Spectral mixture analysis is an approach to estimating the sub-pixel contents of an image pixel based on a set of representaive reflectance spectra (i.e., a reference library). Linear spectral mixture analysis uses an iterative, least-squares fitting approach to estimate the proportions of land cover types based on observed reflectance measurements. In order to run these analyses, you need 1) a high quality reference library of different land cover types, and 2) to resample these reference data to the wavelengths of the instrument you plan to analyze.</p> <p>To support these analysise, <code>earthlib</code> provides a rich spectral library with thousands of labeled reference spectra and tools for working with common satellite instruments.</p>"},{"location":"sources/","title":"Data Sources","text":"<p>The Earth Library is a collection of collections, merging spectral measurments and models from a range of data sources. <code>earthlib</code> provides routines for resampling this collection to match the wavelenghts of many common optical imaging sensors.</p>"},{"location":"sources/#spectral-libraries","title":"Spectral libraries","text":"<p>The following data sources were filtered and resampled prior to inclusion in <code>earthlib</code>.</p> <ul> <li>Vegetation spectra modeled using PROSAIL (using PyPROSAIL)</li> <li>World Agroforestry (ICRAF) Global Soil Spectral Library</li> <li>The Joint Fire Science Program</li> <li>UCSB's Urban Reflectance Spectra</li> <li>UW/BNL/NASA HySPIRI airborne calibration spectra</li> <li>USGS Spectral Library Version 7</li> </ul> <p>Below are plots for the primary land cover spectra included in <code>earthlib</code>.</p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"sources/#supported-sensors","title":"Supported sensors","text":"<p>In the figure above, the black lines indicate the full-width of each band, and the colored squares mark the center wavelength for each band. <code>NEON</code>, an imaging spectrometer system, measures the full shortwave spectrum (400-2500 nm) using over 400 spectral bands to measure continuous spectral variance (these bands have been resampled to match the range/centers of the <code>earthlib</code> reference library).</p>"},{"location":"sources/#measurement-types","title":"Measurement types","text":"<p>The <code>earthlib</code> spectral library are provided in units of surface reflectance: scaled as floating point values from 0-1. Data from the most commonly-used sensors\u2014like Landsat, Sentinel &amp; MODIS\u2014are provided in Earth Engine as surface reflectance products. These datasets can be unmixed once the data have been rescaled: they're typically provided as unsigned integer values from 0-10000.</p> <p>A few data sources are not available as surface reflectance products: <code>ASTER</code> data are provided in radiance (a physical measurement unit, uncorrected for atmospheric composition); <code>ALOS-AVNIR-2</code> data are provided in DN (raw sensor measurments). Though we provide paths to these collections and the wavelengths of these sensors, these data cannot be unmixed as-is using <code>earthlib</code>. You would have to first convert from DN to radiance (in the case of <code>ALOS-AVNIR-2</code>) then apply atmospheric correction (to convert from radiance to reflectance). This workflow isn't supported by <code>earthlib</code>.</p>"},{"location":"sources/#sensors-unavailable-in-earth-engine","title":"Sensors unavailable in Earth Engine","text":"<p><code>earthlib</code> provides sensor definitions for <code>NEON</code> data (a set of airborne imaging spectrometers) and for a set of data from Planet's Dove constellation (<code>PlanetScope</code>, <code>Dove-R</code>, <code>SuperDove</code>). These are not available as default Earth Engine collections. You can, however, upload data from these providers as custom user data or from community-contributed datasets. So you can unmix these datasets if you have access to them as Earth Engine Image/Collection assets, but there is no default collection ID provided by <code>earthlib</code>.</p>"},{"location":"module/BRDFCorrect/","title":"earthlib.BRDFCorrect","text":"<p>Routines to prepare datasets prior to unmixing</p>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.Landsat457","title":"<code>Landsat457(image, scaleFactor=1)</code>","text":"<p>Apply BRDF adjustments to a Landsat ETM+ image</p> <p>As described in www.sciencedirect.com/science/article/pii/S0034425716300220     and groups.google.com/g/google-earth-engine-developers/c/KDqlUCj4LTs/m/hQ5mGodsAQAJ</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>Landsat \u2158/7 surface reflectance image</p> required <code>scaleFactor</code> <code>float</code> <p>a scaling factor to tune the volumetric scattering adjustment</p> <code>1</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>a BRDF-corrected image</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def Landsat457(\n    image: ee.Image,\n    scaleFactor: float = 1,\n) -&gt; ee.Image:\n\"\"\"Apply BRDF adjustments to a Landsat ETM+ image\n\n    As described in https://www.sciencedirect.com/science/article/pii/S0034425716300220\n        and https://groups.google.com/g/google-earth-engine-developers/c/KDqlUCj4LTs/m/hQ5mGodsAQAJ\n\n    Args:\n        image: Landsat 4/5/7 surface reflectance image\n        scaleFactor: a scaling factor to tune the volumetric scattering adjustment\n\n    Returns:\n        a BRDF-corrected image\n    \"\"\"\n    return brdfCorrectWrapper(image, BRDF_COEFFICIENTS_L457, scaleFactor)\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.Landsat8","title":"<code>Landsat8(image, scaleFactor=1)</code>","text":"<p>Apply BRDF adjustments to a Landsat8 image</p> <p>As described in www.sciencedirect.com/science/article/pii/S0034425716300220     and groups.google.com/g/google-earth-engine-developers/c/KDqlUCj4LTs/m/hQ5mGodsAQAJ</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>Landsat8 surface reflectance image</p> required <code>scaleFactor</code> <code>float</code> <p>a scaling factor to tune the volumetric scattering adjustment</p> <code>1</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>a BRDF-corrected image</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def Landsat8(\n    image: ee.Image,\n    scaleFactor: float = 1,\n) -&gt; ee.Image:\n\"\"\"Apply BRDF adjustments to a Landsat8 image\n\n    As described in https://www.sciencedirect.com/science/article/pii/S0034425716300220\n        and https://groups.google.com/g/google-earth-engine-developers/c/KDqlUCj4LTs/m/hQ5mGodsAQAJ\n\n    Args:\n        image: Landsat8 surface reflectance image\n        scaleFactor: a scaling factor to tune the volumetric scattering adjustment\n\n    Returns:\n        a BRDF-corrected image\n    \"\"\"\n    return brdfCorrectWrapper(image, BRDF_COEFFICIENTS_L8, scaleFactor)\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.Sentinel2","title":"<code>Sentinel2(image, scaleFactor=1)</code>","text":"<p>Apply BRDF adjustments to a Sentinel2 image</p> <p>As described in www.sciencedirect.com/science/article/pii/S0034425717302791</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>Sentinel-2 surface reflectance image</p> required <code>scaleFactor</code> <code>float</code> <p>a scaling factor to tune the volumetric scattering adjustment</p> <code>1</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>a BRDF-corrected image</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def Sentinel2(\n    image: ee.Image,\n    scaleFactor: float = 1,\n) -&gt; ee.Image:\n\"\"\"Apply BRDF adjustments to a Sentinel2 image\n\n    As described in https://www.sciencedirect.com/science/article/pii/S0034425717302791\n\n    Args:\n        image: Sentinel-2 surface reflectance image\n        scaleFactor: a scaling factor to tune the volumetric scattering adjustment\n\n    Returns:\n        a BRDF-corrected image\n    \"\"\"\n    return brdfCorrectWrapper(image, BRDF_COEFFICIENTS_S2, scaleFactor)\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.adjustBands","title":"<code>adjustBands(image, coefficientsByBand, scaleFactor=1)</code>","text":"<p>Apply estimated BRDF adjustments band-by-band</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def adjustBands(\n    image: ee.Image, coefficientsByBand: dict, scaleFactor: float = 1\n) -&gt; ee.Image:\n\"\"\"Apply estimated BRDF adjustments band-by-band\"\"\"\n    for bandName in coefficientsByBand:\n        image = applyCFactor(image, bandName, coefficientsByBand[bandName], scaleFactor)\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.anglePrime","title":"<code>anglePrime(image, name, angle)</code>","text":"<p>Prime angle is computed from sun/sensor zenith and used to estimate phase angle</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def anglePrime(image: ee.Image, name: str, angle: str) -&gt; ee.Image:\n\"\"\"Prime angle is computed from sun/sensor zenith and used to estimate phase angle\"\"\"\n    args = {\"br\": 1, \"angle\": angle}\n    image = set(image, \"tanAnglePrime\", \"{br} * tan({angle})\", args)\n    image = setIf(image, \"tanAnglePrime\", \"i.tanAnglePrime &lt; 0\", 0)\n    image = set(image, name, \"atan(i.tanAnglePrime)\")\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.applyCFactor","title":"<code>applyCFactor(image, bandName, coefficients, scaleFactor)</code>","text":"<p>Apply BRDF C-factor adjustments to a single band</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def applyCFactor(\n    image: ee.Image, bandName: str, coefficients: dict, scaleFactor: float\n) -&gt; ee.Image:\n\"\"\"Apply BRDF C-factor adjustments to a single band\"\"\"\n    image = brdf(image, \"brdf\", \"kvol\", \"kgeo\", coefficients, scaleFactor)\n    image = brdf(image, \"brdf0\", \"kvol0\", \"kgeo0\", coefficients, scaleFactor)\n    image = set(image, \"cFactor\", \"i.brdf0 / i.brdf\", coefficients)\n    image = set(\n        image, bandName, \"{bandName} * i.cFactor\", {\"bandName\": \"i.\" + bandName}\n    )\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.brdf","title":"<code>brdf(image, bandName, kvolBand, kgeoBand, coefficients, scaleFactor)</code>","text":"<p>Apply the BRDF volumetric scattering adjustment</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def brdf(\n    image: ee.Image,\n    bandName: str,\n    kvolBand: str,\n    kgeoBand: str,\n    coefficients: dict,\n    scaleFactor: float,\n) -&gt; ee.Image:\n\"\"\"Apply the BRDF volumetric scattering adjustment\"\"\"\n    args = merge_dicts(\n        coefficients,\n        {\n            \"kvol\": f\"{scaleFactor} * i.\" + kvolBand,\n            \"kgeo\": \"i.\" + kgeoBand,\n        },\n    )\n    image = set(image, bandName, \"{fiso} + {fvol} * {kvol} + {fgeo} * {kvol}\", args)\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.brdfCorrectWrapper","title":"<code>brdfCorrectWrapper(image, coefficientsByBand=None, scaleFactor=1)</code>","text":"<p>Wrapper to support keyword arguments that can't be passed during .map() calls</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def brdfCorrectWrapper(\n    image: ee.Image, coefficientsByBand: dict = None, scaleFactor: float = 1\n) -&gt; ee.Image:\n\"\"\"Wrapper to support keyword arguments that can't be passed during .map() calls\"\"\"\n    inputBandNames = image.bandNames()\n    corners = findCorners(image)\n    image = viewAngles(image, corners)\n    image = solarPosition(image)\n    image = sunZenOut(image)\n    image = set(image, \"relativeSunViewAz\", \"i.sunAz - i.viewAz\")\n    image = rossThick(image, \"kvol\", \"i.sunZen\", \"i.viewZen\", \"i.relativeSunViewAz\")\n    image = rossThick(image, \"kvol0\", \"i.sunZenOut\", 0, 0)\n    image = liThin(image, \"kgeo\", \"i.sunZen\", \"i.viewZen\", \"i.relativeSunViewAz\")\n    image = liThin(image, \"kgeo0\", \"i.sunZenOut\", 0, 0)\n    image = adjustBands(image, coefficientsByBand, scaleFactor)\n    return image.select(inputBandNames).toInt16()\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.bySensor","title":"<code>bySensor(sensor)</code>","text":"<p>Get the appropriate BRDF correction function by sensor type.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the BRDF correction function associated with a sensor to pass to a .map() call</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def bySensor(sensor: str) -&gt; Callable:\n\"\"\"Get the appropriate BRDF correction function by sensor type.\n\n    Args:\n        sensor: sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").\n\n    Returns:\n        the BRDF correction function associated with a sensor to pass to a .map() call\n    \"\"\"\n    lookup = {\n        \"Landsat4\": Landsat457,\n        \"Landsat5\": Landsat457,\n        \"Landsat7\": Landsat457,\n        \"Landsat8\": Landsat8,\n        \"Sentinel2\": Sentinel2,\n    }\n    try:\n        function = lookup[sensor]\n        return function\n    except KeyError:\n        supported = \", \".join(lookup.keys())\n        raise SensorError(\n            f\"BRDF adjustment not supported for '{sensor}'. Supported: {supported}\"\n        )\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.cosPhaseAngle","title":"<code>cosPhaseAngle(image, name, sunZen, viewZen, relativeSunViewAz)</code>","text":"<p>Phase angle estimates the relative deviation between sun/sensor geometry</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def cosPhaseAngle(\n    image: ee.Image, name: str, sunZen: str, viewZen: str, relativeSunViewAz: str\n) -&gt; ee.Image:\n\"\"\"Phase angle estimates the relative deviation between sun/sensor geometry\"\"\"\n    args = {\n        \"sunZen\": sunZen,\n        \"viewZen\": viewZen,\n        \"relativeSunViewAz\": relativeSunViewAz,\n    }\n    image = set(\n        image,\n        name,\n        toImage(\n            image,\n            \"cos({sunZen}) * cos({viewZen})\"\n            + \"+ sin({sunZen}) * sin({viewZen}) * cos({relativeSunViewAz})\",\n            args,\n        ).clamp(-1, 1),\n    )\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.findCorners","title":"<code>findCorners(image)</code>","text":"<p>Get corner coordinates from an images 'system:footprint' attribute</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def findCorners(image: ee.Image) -&gt; dict:\n\"\"\"Get corner coordinates from an images 'system:footprint' attribute\"\"\"\n\n    def get_xs(coord):\n        return x(coord)\n\n    def get_ys(coord):\n        return y(coord)\n\n    def findCorner(targetValue, values):\n        def get_diff(value):\n            return ee.Number(value).subtract(targetValue).abs()\n\n        diff = values.map(get_diff)\n        minValue = diff.reduce(ee.Reducer.min())\n        idx = diff.indexOf(minValue)\n        return coords.get(idx)\n\n    footprint = ee.Geometry(image.get(\"system:footprint\"))\n    bounds = ee.List(footprint.bounds().coordinates().get(0))\n    coords = footprint.coordinates()\n    xs = coords.map(get_xs)\n    ys = coords.map(get_ys)\n    lowerLeft = findCorner(x(bounds.get(0)), xs)\n    lowerRight = findCorner(y(bounds.get(1)), ys)\n    upperRight = findCorner(x(bounds.get(2)), xs)\n    upperLeft = findCorner(y(bounds.get(3)), ys)\n    return {\n        \"upperLeft\": upperLeft,\n        \"upperRight\": upperRight,\n        \"lowerRight\": lowerRight,\n        \"lowerLeft\": lowerLeft,\n    }\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.format","title":"<code>format(s, args, constants={'pi': f'{math.pi}'})</code>","text":"<p>Format a string to strip out {} values</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def format(s: str, args: dict, constants: dict = {\"pi\": f\"{math.pi:0.8f}\"}) -&gt; str:\n\"\"\"Format a string to strip out {} values\"\"\"\n    args = args or {}\n    allArgs = merge_dicts(constants, args)\n    vars = re.findall(r\"\\{([A-Za-z0-9_]+)\\}\", s)\n    for var in vars:\n        replacement_var = str(allArgs[var])\n        s = s.replace(\"{\" + f\"{var}\" + \"}\", replacement_var)\n    return s\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.liThin","title":"<code>liThin(image, bandName, sunZen, viewZen, relativeSunViewAz)</code>","text":"<p>From modis.gsfc.nasa.gov/data/atbd/atbd_mod09.pdf</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def liThin(\n    image: ee.Image, bandName: str, sunZen: str, viewZen: str, relativeSunViewAz: str\n) -&gt; ee.Image:\n\"\"\"From https://modis.gsfc.nasa.gov/data/atbd/atbd_mod09.pdf\"\"\"\n    args = {\n        \"sunZen\": sunZen,\n        \"viewZen\": viewZen,\n        \"relativeSunViewAz\": relativeSunViewAz,\n        \"hb\": 2,\n    }\n    image = anglePrime(image, \"sunZenPrime\", sunZen)\n    image = anglePrime(image, \"viewZenPrime\", viewZen)\n    image = cosPhaseAngle(\n        image,\n        \"cosPhaseAnglePrime\",\n        \"i.sunZenPrime\",\n        \"i.viewZenPrime\",\n        relativeSunViewAz,\n    )\n    image = set(\n        image,\n        \"distance\",\n        \"sqrt(pow(tan(i.sunZenPrime), 2) + pow(tan(i.viewZenPrime), 2)\"\n        + \"- 2 * tan(i.sunZenPrime) * tan(i.viewZenPrime) * cos({relativeSunViewAz}))\",\n        args,\n    )\n    image = set(image, \"temp\", \"1/cos(i.sunZenPrime) + 1/cos(i.viewZenPrime)\")\n    image = set(\n        image,\n        \"cosT\",\n        toImage(\n            image,\n            \"{hb} * sqrt(pow(i.distance, 2) + pow(tan(i.sunZenPrime) * tan(i.viewZenPrime) * sin({relativeSunViewAz}), 2))\"\n            + \"/ i.temp\",\n            args,\n        ).clamp(-1, 1),\n    )\n    image = set(image, \"t\", \"acos(i.cosT)\")\n    image = set(image, \"overlap\", \"(1/{pi}) * (i.t - sin(i.t) * i.cosT) * (i.temp)\")\n    image = setIf(image, \"overlap\", \"i.overlap &gt; 0\", 0)\n    image = set(\n        image,\n        bandName,\n        \"i.overlap - i.temp\"\n        + \"+ (1/2) * (1 + i.cosPhaseAnglePrime) * (1/cos(i.sunZenPrime)) * (1/cos(i.viewZenPrime))\",\n    )\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.merge_dicts","title":"<code>merge_dicts(d1, d2)</code>","text":"<p>Create one dictionary from two</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def merge_dicts(d1: dict, d2: dict) -&gt; dict:\n\"\"\"Create one dictionary from two\"\"\"\n    return {**d1, **d2}\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.pointBetween","title":"<code>pointBetween(pointA, pointB)</code>","text":"<p>Compute the cetroid of two points</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def pointBetween(\n    pointA: ee.Geometry.Point, pointB: ee.Geometry.Point\n) -&gt; ee.Geometry.Point:\n\"\"\"Compute the cetroid of two points\"\"\"\n    return ee.Geometry.LineString([pointA, pointB]).centroid().coordinates()\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.rossThick","title":"<code>rossThick(image, bandName, sunZen, viewZen, relativeSunViewAz)</code>","text":"<p>From modis.gsfc.nasa.gov/data/atbd/atbd_mod09.pdf</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def rossThick(\n    image: ee.Image, bandName: str, sunZen: str, viewZen: str, relativeSunViewAz: str\n) -&gt; ee.Image:\n\"\"\"From https://modis.gsfc.nasa.gov/data/atbd/atbd_mod09.pdf\"\"\"\n    args = {\n        \"sunZen\": sunZen,\n        \"viewZen\": viewZen,\n        \"relativeSunViewAz\": relativeSunViewAz,\n    }\n    image = cosPhaseAngle(image, \"cosPhaseAngle\", sunZen, viewZen, relativeSunViewAz)\n    image = set(image, \"phaseAngle\", \"acos(i.cosPhaseAngle)\")\n    image = set(\n        image,\n        bandName,\n        \"(({pi}/2 - i.phaseAngle) * i.cosPhaseAngle + sin(i.phaseAngle)) \"\n        + \"/ (cos({sunZen}) + cos({viewZen})) - {pi}/4\",\n        args,\n    )\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.set","title":"<code>set(image, name, toAdd, args=None)</code>","text":"<p>Append the value of <code>toAdd</code> as a band <code>name</code> to <code>image</code></p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def set(\n    image: ee.Image,\n    name: str,\n    toAdd: str,\n    args: dict = None,\n) -&gt; ee.Image:\n\"\"\"Append the value of `toAdd` as a band `name` to `image`\"\"\"\n    toAdd = toImage(image, toAdd, args)\n    return image.addBands(toAdd.rename(name), None, True)\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.setIf","title":"<code>setIf(image, name, condition, TrueValue, FalseValue=0)</code>","text":"<p>Create a conditional mask and add it as a band to <code>image</code></p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def setIf(\n    image: ee.Image, name: str, condition: str, TrueValue: float, FalseValue: float = 0\n) -&gt; ee.Image:\n\"\"\"Create a conditional mask and add it as a band to `image`\"\"\"\n\n    def invertMask(mask):\n        return mask.multiply(-1).add(1)\n\n    condition = toImage(image, condition)\n    TrueMasked = toImage(image, TrueValue).mask(toImage(image, condition))\n    FalseMasked = toImage(image, FalseValue).mask(invertMask(condition))\n    value = TrueMasked.unmask(FalseMasked)\n    image = set(image, name, value)\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.slopeBetween","title":"<code>slopeBetween(pointA, pointB)</code>","text":"<p>Compute the slope of the distance between two points</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def slopeBetween(\n    pointA: ee.Geometry.Point, pointB: ee.Geometry.Point\n) -&gt; ee.Geometry.Point:\n\"\"\"Compute the slope of the distance between two points\"\"\"\n    return ((y(pointA)).subtract(y(pointB))).divide((x(pointA)).subtract(x(pointB)))\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.solarPosition","title":"<code>solarPosition(image)</code>","text":"<p>Compute solar position from the time of collection</p> <p>From www.pythonfmask.org/en/latest/_modules/fmask/landsatangles.html</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>an ee.Image with a \"system:time_start\" attribute</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>adds a series of solar geometry bands to <code>image</code></p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def solarPosition(image: ee.Image) -&gt; ee.Image:\n\"\"\"Compute solar position from the time of collection\n\n    From https://www.pythonfmask.org/en/latest/_modules/fmask/landsatangles.html\n\n    Args:\n        image: an ee.Image with a \"system:time_start\" attribute\n\n    Returns:\n        adds a series of solar geometry bands to `image`\n    \"\"\"\n    date = ee.Date(ee.Number(image.get(\"system:time_start\")))\n    secondsInHour = 3600\n    image = set(image, \"longDeg\", ee.Image.pixelLonLat().select(\"longitude\"))\n    image = set(\n        image,\n        \"latRad\",\n        ee.Image.pixelLonLat().select(\"latitude\").multiply(math.pi).divide(180),\n    )\n    image = set(\n        image,\n        \"hourGMT\",\n        ee.Number(date.getRelative(\"second\", \"day\")).divide(secondsInHour),\n    )\n    image = set(image, \"jdp\", date.getFraction(\"year\"))  # Julian Date Proportion\n    image = set(image, \"jdpr\", \"i.jdp * 2 * {pi}\")  # Julian Date Proportion in Radians\n    image = set(image, \"meanSolarTime\", \"i.hourGMT + i.longDeg / 15\")\n    image = set(\n        image,\n        \"localSolarDiff\",\n        \"(0.000075 + 0.001868 * cos(i.jdpr) - 0.032077 * sin(i.jdpr)\"\n        + \"- 0.014615 * cos(2 * i.jdpr) - 0.040849 * sin(2 * i.jdpr))\"\n        + \"* 12 * 60 / {pi}\",\n    )\n    image = set(image, \"TrueSolarTime\", \"i.meanSolarTime + i.localSolarDiff / 60 - 12\")\n    image = set(image, \"angleHour\", \"i.TrueSolarTime * 15 * {pi} / 180\")\n    image = set(\n        image,\n        \"delta\",\n        \"0.006918 - 0.399912 * cos(i.jdpr) + 0.070257 * sin(i.jdpr) - 0.006758 * cos(2 * i.jdpr)\"\n        + \"+ 0.000907 * sin(2 * i.jdpr) - 0.002697 * cos(3 * i.jdpr) + 0.001480 * sin(3 * i.jdpr)\",\n    )\n    image = set(\n        image,\n        \"cosSunZen\",\n        \"sin(i.latRad) * sin(i.delta) \"\n        + \"+ cos(i.latRad) * cos(i.delta) * cos(i.angleHour)\",\n    )\n    image = set(image, \"sunZen\", \"acos(i.cosSunZen)\")\n    image = set(\n        image,\n        \"sinSunAzSW\",\n        toImage(image, \"cos(i.delta) * sin(i.angleHour) / sin(i.sunZen)\").clamp(-1, 1),\n    )\n    image = set(\n        image,\n        \"cosSunAzSW\",\n        \"(-cos(i.latRad) * sin(i.delta)\"\n        + \"+ sin(i.latRad) * cos(i.delta) * cos(i.angleHour)) / sin(i.sunZen)\",\n    )\n    image = set(image, \"sunAzSW\", \"asin(i.sinSunAzSW)\")\n    image = setIf(image, \"sunAzSW\", \"i.cosSunAzSW &lt;= 0\", \"{pi} - i.sunAzSW\", \"sunAzSW\")\n    image = setIf(\n        image,\n        \"sunAzSW\",\n        \"i.cosSunAzSW &gt; 0 and i.sinSunAzSW &lt;= 0\",\n        \"2 * {pi} + i.sunAzSW\",\n        \"sunAzSW\",\n    )\n    image = set(image, \"sunAz\", \"i.sunAzSW + {pi}\")\n    image = setIf(image, \"sunAz\", \"i.sunAz &gt; 2 * {pi}\", \"i.sunAz - 2 * {pi}\", \"sunAz\")\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.sunZenOut","title":"<code>sunZenOut(image)</code>","text":"<p>Compute the solar zenith angle from an image center</p> <p>From hls.gsfc.nasa.gov/wp-content/uploads/2016/08/HLS.v1.0.UserGuide.pdf</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>an ee.Image with a \"system:footprint\" attribute</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>adds a \"sunZenOut\" band to <code>image</code></p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def sunZenOut(image: ee.Image) -&gt; ee.Image:\n\"\"\"Compute the solar zenith angle from an image center\n\n    From https://hls.gsfc.nasa.gov/wp-content/uploads/2016/08/HLS.v1.0.UserGuide.pdf\n\n    Args:\n        image: an ee.Image with a \"system:footprint\" attribute\n\n    Returns:\n        adds a \"sunZenOut\" band to `image`\n    \"\"\"\n    image = set(\n        image,\n        \"centerLat\",\n        ee.Number(\n            ee.Geometry(image.get(\"system:footprint\"))\n            .bounds()\n            .centroid(30)\n            .coordinates()\n            .get(0)\n        )\n        .multiply(math.pi)\n        .divide(180),\n    )\n    image = set(\n        image,\n        \"sunZenOut\",\n        \"(31.0076\"\n        + \"- 0.1272 * i.centerLat\"\n        + \"+ 0.01187 * pow(i.centerLat, 2)\"\n        + \"+ 2.40E-05 * pow(i.centerLat, 3)\"\n        + \"- 9.48E-07 * pow(i.centerLat, 4)\"\n        + \"- 1.95E-09 * pow(i.centerLat, 5)\"\n        + \"+ 6.15E-11 * pow(i.centerLat, 6)) * {pi}/180\",\n    )\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.toImage","title":"<code>toImage(image, band, args=None)</code>","text":"<p>Convenience function to convert scalars or expressions to new bands</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def toImage(image: ee.Image, band: str, args: dict = None) -&gt; ee.Image:\n\"\"\"Convenience function to convert scalars or expressions to new bands\"\"\"\n    if type(band) is str:\n        if \".\" in band or \" \" in band or \"{\" in band:\n            band = image.expression(format(band, args), {\"i\": image})\n        else:\n            band = image.select(band)\n    return ee.Image(band)\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.toLine","title":"<code>toLine(pointA, pointB)</code>","text":"<p>Create a LineString from two Points</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def toLine(\n    pointA: ee.Geometry.Point, pointB: ee.Geometry.Point\n) -&gt; ee.Geometry.LineString:\n\"\"\"Create a LineString from two Points\"\"\"\n    return ee.Geometry.LineString([pointA, pointB])\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.viewAngles","title":"<code>viewAngles(image, corners)</code>","text":"<p>Compute sensor view angles</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>an ee.Image</p> required <code>corners</code> <code>dict</code> <p>a dictionary with corner coords. get from findCorners()</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>adds 'viewAz' and 'viewZen' bands to <code>image</code></p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def viewAngles(image: ee.Image, corners: dict) -&gt; ee.Image:\n\"\"\"Compute sensor view angles\n\n    Args:\n        image: an ee.Image\n        corners: a dictionary with corner coords. get from findCorners()\n\n    Returns:\n        adds 'viewAz' and 'viewZen' bands to `image`\n    \"\"\"\n    maxDistanceToSceneEdge = 1000000\n    maxSatelliteZenith = 7.5\n    upperCenter = pointBetween(corners[\"upperLeft\"], corners[\"upperRight\"])\n    lowerCenter = pointBetween(corners[\"lowerLeft\"], corners[\"lowerRight\"])\n    slope = slopeBetween(lowerCenter, upperCenter)\n    slopePerp = ee.Number(-1).divide(slope)\n    image = set(\n        image, \"viewAz\", ee.Image(ee.Number(math.pi / 2).subtract((slopePerp).atan()))\n    )\n    leftLine = toLine(corners[\"upperLeft\"], corners[\"lowerLeft\"])\n    rightLine = toLine(corners[\"upperRight\"], corners[\"lowerRight\"])\n    leftDistance = ee.FeatureCollection(leftLine).distance(maxDistanceToSceneEdge)\n    rightDistance = ee.FeatureCollection(rightLine).distance(maxDistanceToSceneEdge)\n    viewZenith = (\n        rightDistance.multiply(maxSatelliteZenith * 2)\n        .divide(rightDistance.add(leftDistance))\n        .subtract(maxSatelliteZenith)\n    )\n    image = set(image, \"viewZen\", viewZenith.multiply(math.pi).divide(180))\n    return image\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.x","title":"<code>x(point)</code>","text":"<p>Get the X location from a point geometry</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def x(point: ee.Geometry.Point):\n\"\"\"Get the X location from a point geometry\"\"\"\n    return ee.Number(ee.List(point).get(0))\n</code></pre>"},{"location":"module/BRDFCorrect/#earthlib.BRDFCorrect.y","title":"<code>y(point)</code>","text":"<p>Get the Y location from a point geometry</p> Source code in <code>earthlib/BRDFCorrect.py</code> <pre><code>def y(point: ee.Geometry.Point):\n\"\"\"Get the Y location from a point geometry\"\"\"\n    return ee.Number(ee.List(point).get(1))\n</code></pre>"},{"location":"module/BrightMask/","title":"earthlib.BrightMask","text":"<p>Functions for brightness masking earth engine images.</p>"},{"location":"module/BrightMask/#earthlib.BrightMask.Landsat457","title":"<code>Landsat457(img, threshold=0.4)</code>","text":"<p>Apply bright pixel masking to a Landsat \u2158/7 image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels above this value are flagged as bright.</p> <code>0.4</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/BrightMask.py</code> <pre><code>def Landsat457(img: ee.Image, threshold: float = 0.4) -&gt; ee.Image:\n\"\"\"Apply bright pixel masking to a Landsat 4/5/7 image.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels above this value are flagged as bright.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    # remove SWIR2 band where most ground/cloud confusion occurs\n    bands = getBands(\"Landsat7\")\n    bands.remove(\"SR_B7\")\n    subset = img.select()\n    shade = brightMask(subset, threshold)\n    return img.updateMask(shade)\n</code></pre>"},{"location":"module/BrightMask/#earthlib.BrightMask.Landsat8","title":"<code>Landsat8(img, threshold=0.4)</code>","text":"<p>Apply bright pixel masking to a Landsat 8 image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels above this value are flagged as bright.</p> <code>0.4</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/BrightMask.py</code> <pre><code>def Landsat8(img: ee.Image, threshold: float = 0.4) -&gt; ee.Image:\n\"\"\"Apply bright pixel masking to a Landsat 8 image.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels above this value are flagged as bright.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    bands = getBands(\"Landsat8\")\n    bands.remove(\"SR_B7\")\n    subset = img.select(bands)\n    shade = brightMask(subset, threshold)\n    return img.updateMask(shade)\n</code></pre>"},{"location":"module/BrightMask/#earthlib.BrightMask.MODIS","title":"<code>MODIS(img, threshold=0.4)</code>","text":"<p>Apply bright pixel masking to a MODIS image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels above this value are flagged as bright.</p> <code>0.4</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/BrightMask.py</code> <pre><code>def MODIS(img: ee.Image, threshold: float = 0.4) -&gt; ee.Image:\n\"\"\"Apply bright pixel masking to a MODIS image.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels above this value are flagged as bright.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    bands = getBands(\"MODIS\")\n    bands.remove(\"sur_refl_b07\")\n    subset = img.select(bands)\n    shade = brightMask(subset, threshold)\n    return img.updateMask(shade)\n</code></pre>"},{"location":"module/BrightMask/#earthlib.BrightMask.brightMask","title":"<code>brightMask(img, threshold)</code>","text":"<p>Use brightness normalization to identify and remove bright pixels.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels above this value are flagged as bright.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>a pixel byte map with 0 for shade pixels, 1 for bright pixels.</p> Source code in <code>earthlib/BrightMask.py</code> <pre><code>def brightMask(img: ee.Image, threshold: float) -&gt; ee.Image:\n\"\"\"Use brightness normalization to identify and remove bright pixels.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels above this value are flagged as bright.\n\n    Returns:\n        a pixel byte map with 0 for shade pixels, 1 for bright pixels.\n    \"\"\"\n    brightness = img.reduce(ee.Reducer.mean())\n    mask = brightness.lt(threshold)\n    return mask\n</code></pre>"},{"location":"module/BrightMask/#earthlib.BrightMask.bySensor","title":"<code>bySensor(sensor)</code>","text":"<p>Returns the appropriate shade mask function to use by sensor type.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the mask function associated with a sensor to pass to an ee .map() call</p> Source code in <code>earthlib/BrightMask.py</code> <pre><code>def bySensor(sensor: str) -&gt; Callable:\n\"\"\"Returns the appropriate shade mask function to use by sensor type.\n\n    Args:\n        sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").\n\n    Returns:\n        the mask function associated with a sensor to pass to an ee .map() call\n    \"\"\"\n    lookup = {\n        \"Landsat4\": Landsat457,\n        \"Landsat5\": Landsat457,\n        \"Landsat7\": Landsat457,\n        \"Landsat8\": Landsat8,\n        \"MODIS\": MODIS,\n    }\n    try:\n        function = lookup[sensor]\n        return function\n    except KeyError:\n        supported = \", \".join(lookup.keys())\n        raise SensorError(\n            f\"Shade masking not supported for '{sensor}'. Supported: {supported}\"\n        )\n</code></pre>"},{"location":"module/CloudMask/","title":"earthlib.CloudMask","text":"<p>Functions for cloud masking earth engine images.</p>"},{"location":"module/CloudMask/#earthlib.CloudMask.Landsat4578","title":"<code>Landsat4578(img)</code>","text":"<p>Cloud-mask Landsat images based on the QA bands.</p> <p>See gis.stackexchange.com/questions/349371/creating-cloud-free-images-out-of-a-mod09a1-modis-image-in-gee Previously: gis.stackexchange.com/questions/425159/how-to-make-a-cloud-free-composite-for-landsat-8-collection-2-surface-reflectanc/425160</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have Landsat \"QA_PIXEL\" and \"QA_RADSAT\" band.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def Landsat4578(img: ee.Image) -&gt; ee.Image:\n\"\"\"Cloud-mask Landsat images based on the QA bands.\n\n    See https://gis.stackexchange.com/questions/349371/creating-cloud-free-images-out-of-a-mod09a1-modis-image-in-gee\n    Previously: https://gis.stackexchange.com/questions/425159/how-to-make-a-cloud-free-composite-for-landsat-8-collection-2-surface-reflectanc/425160\n\n    Args:\n        img: the ee.Image to mask. Must have Landsat \"QA_PIXEL\" and \"QA_RADSAT\" band.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    qa = img.select(\"QA_PIXEL\")\n    sat = img.select(\"QA_RADSAT\")\n\n    dilatedCloud = bitwiseSelect(qa, 1).eq(0)\n    cirrus = bitwiseSelect(qa, 2).eq(0)\n    cloud = bitwiseSelect(qa, 3).eq(0)\n    cloudShadow = bitwiseSelect(qa, 4).eq(0)\n    snow = bitwiseSelect(qa, 5).eq(0)\n    qaMask = dilatedCloud.And(cirrus).And(cloud).And(cloudShadow).And(snow)\n\n    satMask = sat.eq(0)\n    jointMask = qaMask.And(satMask)\n\n    return img.updateMask(jointMask)\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.MODIS","title":"<code>MODIS(img)</code>","text":"<p>Mask MODIS images using the QA band.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Requires a \"state_1km\" band.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def MODIS(img: ee.Image) -&gt; ee.Image:\n\"\"\"Mask MODIS images using the QA band.\n\n    Args:\n        img: the ee.Image to mask. Requires a \"state_1km\" band.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    qa = img.select(\"state_1km\")\n\n    clearMask = bitwiseSelect(qa, 0, 1).eq(0)\n    shadowMask = bitwiseSelect(qa, 2).eq(0)\n    aerosolMask = bitwiseSelect(qa, 6, 7).lte(1)\n    cirrusMask = bitwiseSelect(qa, 8, 9).eq(0)\n    cloudMask = bitwiseSelect(qa, 10).eq(0)\n    fireMask = bitwiseSelect(qa, 11).eq(0)\n    snowMask = bitwiseSelect(qa, 15).eq(0)\n\n    mask = (\n        clearMask.And(shadowMask)\n        .And(aerosolMask)\n        .And(cirrusMask)\n        .And(cloudMask)\n        .And(fireMask)\n        .And(snowMask)\n    )\n    return img.updateMask(mask)\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.Opening","title":"<code>Opening(img, iterations=3)</code>","text":"<p>Apply a morphological opening filter to an image mask.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have a mask band set.</p> required <code>iterations</code> <code>int</code> <p>the number of sequential dilate/erode operations.</p> <code>3</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the input image with an updated, opened mask.</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def Opening(img: ee.Image, iterations: int = 3) -&gt; ee.Image:\n\"\"\"Apply a morphological opening filter to an image mask.\n\n    Args:\n        img: the ee.Image to mask. Must have a mask band set.\n        iterations: the number of sequential dilate/erode operations.\n\n    Returns:\n        the input image with an updated, opened mask.\n    \"\"\"\n    mask = img.mask()\n    kernel = ee.Kernel.circle(iterations)\n    dilateOpts = {\"kernel\": kernel, \"iterations\": iterations}\n    erodeOpts = {\"kernel\": kernel, \"iterations\": iterations}\n    openedMask = mask.focalMin(**dilateOpts).focalMax(**erodeOpts)\n\n    return img.updateMask(openedMask)\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.Sentinel2","title":"<code>Sentinel2(img, use_qa=True, use_scl=True)</code>","text":"<p>Mask Sentinel2 images using multiple masking approaches.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask.</p> required <code>use_qa</code> <code>bool</code> <p>apply QA band cloud masking. img must have a \"QA60\" band.</p> <code>True</code> <code>use_scl</code> <code>bool</code> <p>apply SCL band cloud masking. img must have a \"SCL\" band.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def Sentinel2(img: ee.Image, use_qa: bool = True, use_scl: bool = True) -&gt; ee.Image:\n\"\"\"Mask Sentinel2 images using multiple masking approaches.\n\n    Args:\n        img: the ee.Image to mask.\n        use_qa: apply QA band cloud masking. img must have a \"QA60\" band.\n        use_scl: apply SCL band cloud masking. img must have a \"SCL\" band.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    if use_qa:\n        img = Sentinel2QA(img)\n\n    if use_scl:\n        img = Sentinel2SCL(img)\n\n    return img\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.Sentinel2QA","title":"<code>Sentinel2QA(img)</code>","text":"<p>Mask Sentinel2 images using the QA band.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have a Sentinel \"QA60\" band.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def Sentinel2QA(img: ee.Image) -&gt; ee.Image:\n\"\"\"Mask Sentinel2 images using the QA band.\n\n    Args:\n        img: the ee.Image to mask. Must have a Sentinel \"QA60\" band.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    qa = img.select(\"QA60\")\n    cloud = bitwiseSelect(qa, 10).eq(0)\n    cirrus = bitwiseSelect(qa, 11).eq(0)\n    mask = cloud.And(cirrus)\n\n    return img.updateMask(mask)\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.Sentinel2SCL","title":"<code>Sentinel2SCL(img)</code>","text":"<p>Mask Sentinel2 images using scene classification labels.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have a Sentinel \"SCL\" class band.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def Sentinel2SCL(img: ee.Image) -&gt; ee.Image:\n\"\"\"Mask Sentinel2 images using scene classification labels.\n\n    Args:\n        img: the ee.Image to mask. Must have a Sentinel \"SCL\" class band.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    scl = img.select(\"SCL\")\n\n    # class labels\n    sat = scl.neq(1)\n    shadow = scl.neq(3)\n    cloudLow = scl.neq(7)\n    cloudMed = scl.neq(8)\n    cloudHigh = scl.neq(9)\n    cirrus = scl.neq(10)\n    bareSoil = scl.eq(5)\n    baseMask = sat.And(shadow).And(cloudLow).And(cloudMed).And(cloudHigh).And(cirrus)\n\n    # apply morphological closing to clean up one/two pixel cloud predictions\n    cleanupKernel = ee.Kernel.circle(2)\n    focalOpts = {\"kernel\": cleanupKernel, \"iterations\": 1}\n    erodedMask = baseMask.focalMax(**focalOpts).focalMin(**focalOpts)\n\n    # include a search radius to include false positive bare soil predictions near clouds\n    euclidean = ee.Kernel.euclidean(1000, \"meters\")\n    distToCloud = erodedMask.subtract(1).distance(euclidean).unmask()\n    notBare = ee.Image(1).subtract(bareSoil.And(distToCloud.lte(100)))\n    cloudBareMask = erodedMask.And(notBare)\n\n    return img.updateMask(cloudBareMask)\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.VIIRS","title":"<code>VIIRS(img)</code>","text":"<p>Mask VIIRS images using QA bands.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have \"QF1\", \"QF2\" and \"QF7\" bands.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def VIIRS(img: ee.Image) -&gt; ee.Image:\n\"\"\"Mask VIIRS images using QA bands.\n\n    Args:\n        img: the ee.Image to mask. Must have \"QF1\", \"QF2\" and \"QF7\" bands.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    qf1 = img.select(\"QF1\")\n    qf2 = img.select(\"QF2\")\n    qf7 = img.select(\"QF7\")\n\n    clearMask = bitwiseSelect(qf1, 2, 3).eq(0)\n    dayMask = bitwiseSelect(qf1, 4).eq(0)\n    shadowMask = bitwiseSelect(qf2, 3).eq(0)\n    snowMask = bitwiseSelect(qf2, 5).eq(0)\n    cirrus1Mask = bitwiseSelect(qf2, 6).eq(0)\n    cirrus2Mask = bitwiseSelect(qf2, 7).eq(0)\n    adjacentMask = bitwiseSelect(qf7, 1).eq(0)\n    thinCirrusMask = bitwiseSelect(qf7, 4).eq(0)\n\n    mask = (\n        clearMask.And(dayMask)\n        .And(shadowMask)\n        .And(snowMask)\n        .And(cirrus1Mask)\n        .And(cirrus2Mask)\n        .And(adjacentMask)\n        .And(thinCirrusMask)\n    )\n\n    return img.updateMask(mask)\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.bitwiseSelect","title":"<code>bitwiseSelect(img, fromBit, toBit=None)</code>","text":"<p>Filter QA bit masks.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the QA band image</p> required <code>fromBit</code> <code>int</code> <p>QA start bit</p> required <code>toBit</code> <code>int</code> <p>QA end bit</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>encoded bitmap for the passed QA bits</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def bitwiseSelect(img: ee.Image, fromBit: int, toBit: int = None) -&gt; ee.Image:\n\"\"\"Filter QA bit masks.\n\n    Args:\n        img: the QA band image\n        fromBit: QA start bit\n        toBit: QA end bit\n\n    Returns:\n        encoded bitmap for the passed QA bits\n    \"\"\"\n    toBit = fromBit if toBit is None else toBit\n    size = ee.Number(1).add(toBit).subtract(fromBit)\n    mask = ee.Number(1).leftShift(size).subtract(1)\n    return img.rightShift(fromBit).bitwiseAnd(mask)\n</code></pre>"},{"location":"module/CloudMask/#earthlib.CloudMask.bySensor","title":"<code>bySensor(sensor)</code>","text":"<p>Returns the appropriate cloud mask function to use by sensor type.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the mask function associated with a sensor to pass to an ee .map() call</p> Source code in <code>earthlib/CloudMask.py</code> <pre><code>def bySensor(sensor: str) -&gt; Callable:\n\"\"\"Returns the appropriate cloud mask function to use by sensor type.\n\n    Args:\n        sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").\n\n    Returns:\n        the mask function associated with a sensor to pass to an ee .map() call\n    \"\"\"\n    lookup = {\n        \"Landsat4\": Landsat4578,\n        \"Landsat5\": Landsat4578,\n        \"Landsat7\": Landsat4578,\n        \"Landsat8\": Landsat4578,\n        \"Sentinel2\": Sentinel2,\n        \"MODIS\": MODIS,\n        \"VIIRS\": VIIRS,\n    }\n    try:\n        function = lookup[sensor]\n        return function\n    except KeyError:\n        supported = \", \".join(lookup.keys())\n        raise SensorError(\n            f\"Cloud masking not supported for '{sensor}'. Supported: {supported}\"\n        )\n</code></pre>"},{"location":"module/NIRv/","title":"earthlib.NIRv","text":"<p>Methods for computing NIRv (near infrared reflectance of vegetation) from ee.Image data</p>"},{"location":"module/NIRv/#earthlib.NIRv.ASTER","title":"<code>ASTER(image)</code>","text":"<p>Transform ASTER image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def ASTER(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform ASTER image data to scaled reflectance values\"\"\"\n    sensor = \"ASTER\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.AVNIR2","title":"<code>AVNIR2(image)</code>","text":"<p>Transform ALOS-AVNIR2 image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def AVNIR2(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform ALOS-AVNIR2 image data to scaled reflectance values\"\"\"\n    sensor = \"AVNIR2\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.DoveR","title":"<code>DoveR(image)</code>","text":"<p>Transform Planet DoveR image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def DoveR(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Planet DoveR image data to scaled reflectance values\"\"\"\n    sensor = \"DoveR\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.Landsat4","title":"<code>Landsat4(image)</code>","text":"<p>Transform Landsat4 image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def Landsat4(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat4 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat4\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.Landsat5","title":"<code>Landsat5(image)</code>","text":"<p>Transform Landsat5 image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def Landsat5(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat5 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat5\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.Landsat7","title":"<code>Landsat7(image)</code>","text":"<p>Transform Landsat7 image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def Landsat7(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat7 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat7\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.Landsat8","title":"<code>Landsat8(image)</code>","text":"<p>Transform Landsat8 image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def Landsat8(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat8 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat8\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.MODIS","title":"<code>MODIS(image)</code>","text":"<p>Transform MODIS image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def MODIS(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform MODIS image data to scaled reflectance values\"\"\"\n    sensor = \"MODIS\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.NIRvWrapper","title":"<code>NIRvWrapper(image, red_band, nir_band)</code>","text":"<p>Compute NIRv for an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>the input image object.</p> required <code>red_band</code> <code>str</code> <p>the name of the red band to use</p> required <code>nir_band</code> <code>str</code> <p>the name of the near infrared band to use</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>appends the input image with and \"NIRv\" band.</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def NIRvWrapper(image: ee.Image, red_band: str, nir_band: str) -&gt; ee.Image:\n\"\"\"Compute NIRv for an image.\n\n    Args:\n        image: the input image object.\n        red_band: the name of the red band to use\n        nir_band: the name of the near infrared band to use\n\n    Returns:\n        appends the input image with and \"NIRv\" band.\n    \"\"\"\n    red = image.select(red_band)\n    nir = image.select(nir_band)\n    ndvi = (nir.subtract(red)).divide(nir.add(red))\n    ndviScaled = ndvi.subtract(0.08)\n    nirv = ndviScaled.multiply(nir).rename(\"NIRv\")\n    return image.addBands(nirv)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.PlanetScope","title":"<code>PlanetScope(image)</code>","text":"<p>Transform PlanetScope image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def PlanetScope(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform PlanetScope image data to scaled reflectance values\"\"\"\n    sensor = \"PlanetScope\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.Sentinel2","title":"<code>Sentinel2(image)</code>","text":"<p>Transform Sentinel2 image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def Sentinel2(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Sentinel2 image data to scaled reflectance values\"\"\"\n    sensor = \"Sentinel2\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.SuperDove","title":"<code>SuperDove(image)</code>","text":"<p>Transform Planet SuperDove image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def SuperDove(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Planet SuperDove image data to scaled reflectance values\"\"\"\n    sensor = \"SuperDove\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.VIIRS","title":"<code>VIIRS(image)</code>","text":"<p>Transform VIIRS image data to scaled reflectance values</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def VIIRS(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform VIIRS image data to scaled reflectance values\"\"\"\n    sensor = \"VIIRS\"\n    red, nir = getNIRvBands(sensor)\n    return NIRvWrapper(image, red, nir)\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.bySensor","title":"<code>bySensor(sensor)</code>","text":"<p>Returns the appropriate NIRv function to use by sensor type.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the NIRv function associated with a sensor to pass to an ee .map() call</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def bySensor(sensor: str) -&gt; Callable:\n\"\"\"Returns the appropriate NIRv function to use by sensor type.\n\n    Args:\n        sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").\n\n    Returns:\n        the NIRv function associated with a sensor to pass to an ee .map() call\n    \"\"\"\n    lookup = {\n        \"ASTER\": ASTER,\n        \"AVNIR2\": AVNIR2,\n        \"DoveR\": DoveR,\n        \"Landsat4\": Landsat4,\n        \"Landsat5\": Landsat5,\n        \"Landsat7\": Landsat7,\n        \"Landsat8\": Landsat8,\n        \"MODIS\": MODIS,\n        \"PlanetScope\": PlanetScope,\n        \"Sentinel2\": Sentinel2,\n        \"SuperDove\": SuperDove,\n        \"VIIRS\": VIIRS,\n    }\n    try:\n        function = lookup[sensor]\n        return function\n    except KeyError:\n        supported = \", \".join(lookup.keys())\n        raise SensorError(\n            f\"NIRv calculation not supported for '{sensor}'. Supported: {supported}\"\n        )\n</code></pre>"},{"location":"module/NIRv/#earthlib.NIRv.getNIRvBands","title":"<code>getNIRvBands(sensor)</code>","text":"<p>Look-up the red and near infrared bands for NIRv calculation</p> Source code in <code>earthlib/NIRv.py</code> <pre><code>def getNIRvBands(sensor: str) -&gt; tuple:\n\"\"\"Look-up the red and near infrared bands for NIRv calculation\"\"\"\n    bnames = getBands(sensor)\n    descriptions = getBandDescriptions(sensor)\n    idx_red = descriptions.index(\"red\")\n    idx_nir = descriptions.index(\"near infrared\")\n    red = bnames[idx_red]\n    nir = bnames[idx_nir]\n    return red, nir\n</code></pre>"},{"location":"module/Scale/","title":"earthlib.Scale","text":"<p>Methods for scaling image data to normalized reflectance values (0-1 float)</p>"},{"location":"module/Scale/#earthlib.Scale.ASTER","title":"<code>ASTER(image)</code>","text":"<p>Transform ASTER image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def ASTER(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform ASTER image data to scaled reflectance values\"\"\"\n    sensor = \"ASTER\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.AVNIR2","title":"<code>AVNIR2(image)</code>","text":"<p>Transform ALOS-AVNIR2 image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def AVNIR2(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform ALOS-AVNIR2 image data to scaled reflectance values\"\"\"\n    sensor = \"AVNIR2\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.DoveR","title":"<code>DoveR(image)</code>","text":"<p>Transform Planet Dove-R image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def DoveR(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Planet Dove-R image data to scaled reflectance values\"\"\"\n    sensor = \"DoveR\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.Landsat4","title":"<code>Landsat4(image)</code>","text":"<p>Transform Landsat4 image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def Landsat4(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat4 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat4\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.Landsat5","title":"<code>Landsat5(image)</code>","text":"<p>Transform Landsat5 image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def Landsat5(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat5 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat5\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.Landsat7","title":"<code>Landsat7(image)</code>","text":"<p>Transform Landsat7 image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def Landsat7(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat7 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat7\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.Landsat8","title":"<code>Landsat8(image)</code>","text":"<p>Transform Landsat8 image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def Landsat8(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Landsat8 image data to scaled reflectance values\"\"\"\n    sensor = \"Landsat8\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.MODIS","title":"<code>MODIS(image)</code>","text":"<p>Transform MODIS image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def MODIS(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform MODIS image data to scaled reflectance values\"\"\"\n    sensor = \"MODIS\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.NEON","title":"<code>NEON(image)</code>","text":"<p>Transform NEON image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def NEON(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform NEON image data to scaled reflectance values\"\"\"\n    sensor = \"NEON\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.PlanetScope","title":"<code>PlanetScope(image)</code>","text":"<p>Transform PlanetScope image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def PlanetScope(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform PlanetScope image data to scaled reflectance values\"\"\"\n    sensor = \"PlanetScope\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.Sentinel2","title":"<code>Sentinel2(image)</code>","text":"<p>Transform Sentinel2 image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def Sentinel2(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Sentinel2 image data to scaled reflectance values\"\"\"\n    sensor = \"Sentinel2\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.SuperDove","title":"<code>SuperDove(image)</code>","text":"<p>Transform Planet SuperDove image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def SuperDove(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform Planet SuperDove image data to scaled reflectance values\"\"\"\n    sensor = \"SuperDove\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.VIIRS","title":"<code>VIIRS(image)</code>","text":"<p>Transform VIIRS image data to scaled reflectance values</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def VIIRS(image: ee.Image) -&gt; ee.Image:\n\"\"\"Transform VIIRS image data to scaled reflectance values\"\"\"\n    sensor = \"VIIRS\"\n    scale, offset = getScaleParams(sensor)\n    return scaleWrapper(image, scale, offset)\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.bySensor","title":"<code>bySensor(sensor)</code>","text":"<p>Returns the appropriate scaling function to use by sensor type.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the scale function associated with a sensor to pass to an ee .map() call</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def bySensor(sensor: str) -&gt; Callable:\n\"\"\"Returns the appropriate scaling function to use by sensor type.\n\n    Args:\n        sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").\n\n    Returns:\n        the scale function associated with a sensor to pass to an ee .map() call\n    \"\"\"\n    lookup = {\n        \"ASTER\": ASTER,\n        \"AVNIR2\": AVNIR2,\n        \"DoveR\": DoveR,\n        \"Landsat4\": Landsat4,\n        \"Landsat5\": Landsat5,\n        \"Landsat7\": Landsat7,\n        \"Landsat8\": Landsat8,\n        \"MODIS\": MODIS,\n        \"NEON\": NEON,\n        \"PlanetScope\": PlanetScope,\n        \"Sentinel2\": Sentinel2,\n        \"SuperDove\": SuperDove,\n        \"VIIRS\": VIIRS,\n    }\n    try:\n        function = lookup[sensor]\n        return function\n    except KeyError:\n        supported = \", \".join(lookup.keys())\n        raise SensorError(\n            f\"Scaling adjustment not supported for '{sensor}'. Supported: {supported}\"\n        )\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.getScaleParams","title":"<code>getScaleParams(sensor)</code>","text":"<p>Look-up the scale and offset values for a sensor</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def getScaleParams(sensor: str) -&gt; tuple:\n\"\"\"Look-up the scale and offset values for a sensor\"\"\"\n    scale = collections[sensor].get(\"scale\", 1)\n    offset = collections[sensor].get(\"offset\", 0)\n    return scale, offset\n</code></pre>"},{"location":"module/Scale/#earthlib.Scale.scaleWrapper","title":"<code>scaleWrapper(image, scale=1, offset=0)</code>","text":"<p>Apply image rescaling and offset adjustments</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>the input image object</p> required <code>scale</code> <code>float</code> <p>the image rescaling factor</p> <code>1</code> <code>offset</code> <code>float</code> <p>the image offset factor</p> <code>0</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the input rescaled as a 0-1 floating point image</p> Source code in <code>earthlib/Scale.py</code> <pre><code>def scaleWrapper(image: ee.Image, scale: float = 1, offset: float = 0) -&gt; ee.Image:\n\"\"\"Apply image rescaling and offset adjustments\n\n    Args:\n        image: the input image object\n        scale: the image rescaling factor\n        offset: the image offset factor\n\n    Returns:\n        the input rescaled as a 0-1 floating point image\n    \"\"\"\n    scaled = image.multiply(scale).add(offset)\n    return scaled.toFloat()\n</code></pre>"},{"location":"module/ShadeMask/","title":"earthlib.ShadeMask","text":"<p>Functions for shade masking earth engine images.</p>"},{"location":"module/ShadeMask/#earthlib.ShadeMask.Landsat457","title":"<code>Landsat457(img, threshold=0.045)</code>","text":"<p>Apply shade masking to a Landsat \u2158/7 image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels below this value are flagged as shade.</p> <code>0.045</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/ShadeMask.py</code> <pre><code>def Landsat457(img: ee.Image, threshold: float = 0.045) -&gt; ee.Image:\n\"\"\"Apply shade masking to a Landsat 4/5/7 image.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels below this value are flagged as shade.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    # remove NIR band to ignore multiple scattering\n    bands = getBands(\"Landsat7\")\n    bands.remove(\"SR_B4\")\n    subset = img.select(bands)\n    shade = shadeMask(subset, threshold)\n    return img.updateMask(shade)\n</code></pre>"},{"location":"module/ShadeMask/#earthlib.ShadeMask.Landsat8","title":"<code>Landsat8(img, threshold=0.045)</code>","text":"<p>Apply shade masking to a Landsat 8 image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels below this value are flagged as shade.</p> <code>0.045</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/ShadeMask.py</code> <pre><code>def Landsat8(img: ee.Image, threshold: float = 0.045) -&gt; ee.Image:\n\"\"\"Apply shade masking to a Landsat 8 image.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels below this value are flagged as shade.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    bands = getBands(\"Landsat8\")\n    bands.remove(\"SR_B5\")\n    subset = img.select(bands)\n    shade = shadeMask(subset, threshold)\n    return img.updateMask(shade)\n</code></pre>"},{"location":"module/ShadeMask/#earthlib.ShadeMask.MODIS","title":"<code>MODIS(img, threshold=0.045)</code>","text":"<p>Apply shade masking to a MODIS image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels below this value are flagged as shade.</p> <code>0.045</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/ShadeMask.py</code> <pre><code>def MODIS(img: ee.Image, threshold: float = 0.045) -&gt; ee.Image:\n\"\"\"Apply shade masking to a MODIS image.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels below this value are flagged as shade.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    bands = getBands(\"MODIS\")\n    bands.remove(\"sur_refl_b02\")\n    bands.remove(\"sur_refl_b05\")\n    subset = img.select(bands)\n    shade = shadeMask(subset, threshold)\n    return img.updateMask(shade)\n</code></pre>"},{"location":"module/ShadeMask/#earthlib.ShadeMask.bySensor","title":"<code>bySensor(sensor)</code>","text":"<p>Returns the appropriate shade mask function to use by sensor type.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the mask function associated with a sensor to pass to an ee .map() call</p> Source code in <code>earthlib/ShadeMask.py</code> <pre><code>def bySensor(sensor: str) -&gt; Callable:\n\"\"\"Returns the appropriate shade mask function to use by sensor type.\n\n    Args:\n        sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").\n\n    Returns:\n        the mask function associated with a sensor to pass to an ee .map() call\n    \"\"\"\n    lookup = {\n        \"Landsat4\": Landsat457,\n        \"Landsat5\": Landsat457,\n        \"Landsat7\": Landsat457,\n        \"Landsat8\": Landsat8,\n        \"MODIS\": MODIS,\n    }\n    try:\n        function = lookup[sensor]\n        return function\n    except KeyError:\n        supported = \", \".join(lookup.keys())\n        raise SensorError(\n            f\"Shade masking not supported for '{sensor}'. Supported: {supported}\"\n        )\n</code></pre>"},{"location":"module/ShadeMask/#earthlib.ShadeMask.shadeMask","title":"<code>shadeMask(img, threshold)</code>","text":"<p>Use brightness normalization to identify and remove dark pixels.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to shade mask.</p> required <code>threshold</code> <code>float</code> <p>the brightness/reflectance value to exclude. pixels below this value are flagged as shade.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>a pixel byte map with 0 for shade pixels, 1 for bright pixels.</p> Source code in <code>earthlib/ShadeMask.py</code> <pre><code>def shadeMask(img: ee.Image, threshold: float) -&gt; ee.Image:\n\"\"\"Use brightness normalization to identify and remove dark pixels.\n\n    Args:\n        img: the ee.Image to shade mask.\n        threshold: the brightness/reflectance value to exclude.\n            pixels below this value are flagged as shade.\n\n    Returns:\n        a pixel byte map with 0 for shade pixels, 1 for bright pixels.\n    \"\"\"\n    brightness = img.reduce(ee.Reducer.mean())\n    mask = brightness.gt(threshold)\n    return mask\n</code></pre>"},{"location":"module/ThresholdMask/","title":"ThresholdMask","text":"<p>Functions for cloud masking earth engine images based on band thresholds.</p>"},{"location":"module/ThresholdMask/#earthlib.ThresholdMask.Landsat457","title":"<code>Landsat457(img, probability_threshold=0.4)</code>","text":"<p>Compute cloud probability using a series of band ratios and apply a mask threshold.</p> <p>See Sun &amp; Tian 2017: www.sciencedirect.com/science/article/pii/S0924271616306189</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have all the \"SR_*\" reflectance bands.</p> required <code>probability_threshold</code> <code>float</code> <p>pixels above this threshold are included in the mask.</p> <code>0.4</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/ThresholdMask.py</code> <pre><code>def Landsat457(img: ee.Image, probability_threshold: float = 0.4) -&gt; ee.Image:\n\"\"\"Compute cloud probability using a series of band ratios and apply a mask threshold.\n\n    See Sun &amp; Tian 2017: https://www.sciencedirect.com/science/article/pii/S0924271616306189\n\n    Args:\n        img: the ee.Image to mask. Must have all the \"SR_*\" reflectance bands.\n        probability_threshold: pixels above this threshold are included in the mask.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    # band specifications\n    blue = img.select(\"SR_B1\")\n    green = img.select(\"SR_B2\")\n    red = img.select(\"SR_B3\")\n    nir = img.select(\"SR_B4\")\n    swir1 = img.select(\"SR_B5\")\n    swir2 = img.select(\"SR_B7\")\n\n    # single band thresholds\n    s1 = blue.gt(0.2)\n    s2 = green.gt(0.2)\n    s3 = red.gt(0.21)\n    s4 = swir1.gt(0.29)\n    s5 = swir2.gt(0.25)\n\n    # multi-band thresholds\n    m3 = blue.gt(0.16).And(nir.gt(0.26))\n    m4 = blue.gt(0.20).And(swir1.gt(0.20))\n    m5 = green.gt(0.12).And(nir.gt(0.32))\n    m6 = red.gt(0.14).And(nir.gt(0.35))\n    m7 = nir.gt(0.40).And(swir1.gt(0.30))\n\n    # band ratio\n    ratio = swir1.divide(swir2)\n    ratio_thresh = ratio.gt(0.91).And(ratio.lt(1.83))\n\n    # merge and average the results\n    stack = s1.addBands([s2, s3, s4, s5, m1, m2, m3, m4, m5, m6, m7, ratio_thresh])\n    probability = stack.reduce(ee.Reducer.mean())\n    mask = probability.lt(probability_threshold)\n\n    return img.updateMask(mask)\n</code></pre>"},{"location":"module/ThresholdMask/#earthlib.ThresholdMask.Landsat8","title":"<code>Landsat8(img, probability_threshold=0.4)</code>","text":"<p>Compute cloud probability using a series of band ratios and apply a mask threshold.</p> <p>See Sun &amp; Tian 2017: www.sciencedirect.com/science/article/pii/S0924271616306189</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have all the \"SR_*\" reflectance bands.</p> required <code>probability_threshold</code> <code>float</code> <p>pixels above this threshold are included in the mask.</p> <code>0.4</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/ThresholdMask.py</code> <pre><code>def Landsat8(img: ee.Image, probability_threshold: float = 0.4) -&gt; ee.Image:\n\"\"\"Compute cloud probability using a series of band ratios and apply a mask threshold.\n\n    See Sun &amp; Tian 2017: https://www.sciencedirect.com/science/article/pii/S0924271616306189\n\n    Args:\n        img: the ee.Image to mask. Must have all the \"SR_*\" reflectance bands.\n        probability_threshold: pixels above this threshold are included in the mask.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    # band specifications\n    ultrablue = img.select(\"SR_B1\")\n    blue = img.select(\"SR_B2\")\n    green = img.select(\"SR_B3\")\n    red = img.select(\"SR_B4\")\n    nir = img.select(\"SR_B5\")\n    swir1 = img.select(\"SR_B6\")\n    swir2 = img.select(\"SR_B7\")\n\n    # single band thresholds\n    s1 = blue.gt(0.2)\n    s2 = green.gt(0.2)\n    s3 = red.gt(0.21)\n    s4 = swir1.gt(0.29)\n    s5 = swir2.gt(0.25)\n\n    # multi-band thresholds\n    m1 = ultrablue.gt(0.24).And(nir.gt(0.26))\n    m2 = ultrablue.gt(0.24).And(swir1.gt(0.20))\n    m3 = blue.gt(0.16).And(nir.gt(0.26))\n    m4 = blue.gt(0.20).And(swir1.gt(0.20))\n    m5 = green.gt(0.12).And(nir.gt(0.32))\n    m6 = red.gt(0.14).And(nir.gt(0.35))\n    m7 = nir.gt(0.40).And(swir1.gt(0.30))\n\n    # band ratio\n    ratio = swir1.divide(swir2)\n    ratio_thresh = ratio.gt(0.91).And(ratio.lt(1.83))\n\n    # merge and average the results\n    stack = s1.addBands([s2, s3, s4, s5, m1, m2, m3, m4, m5, m6, m7, ratio_thresh])\n    probability = stack.reduce(ee.Reducer.mean())\n    mask = probability.lt(probability_threshold)\n\n    return img.updateMask(mask)\n</code></pre>"},{"location":"module/ThresholdMask/#earthlib.ThresholdMask.MODIS","title":"<code>MODIS(img, probability_threshold=0.6)</code>","text":"<p>Compute cloud probability using a series of band ratios and apply a mask threshold.</p> <p>See Sun &amp; Tian 2017: www.sciencedirect.com/science/article/pii/S0924271616306189</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have all the \"sur_refl_b*\" reflectance bands.</p> required <code>probability_threshold</code> <code>float</code> <p>pixels above this threshold are included in the mask.</p> <code>0.6</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/ThresholdMask.py</code> <pre><code>def MODIS(img: ee.Image, probability_threshold: float = 0.6) -&gt; ee.Image:\n\"\"\"Compute cloud probability using a series of band ratios and apply a mask threshold.\n\n    See Sun &amp; Tian 2017: https://www.sciencedirect.com/science/article/pii/S0924271616306189\n\n    Args:\n        img: the ee.Image to mask. Must have all the \"sur_refl_b*\" reflectance bands.\n        probability_threshold: pixels above this threshold are included in the mask.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    # band specifications\n    b1 = img.select(\"sur_refl_b01\")\n    b2 = img.select(\"sur_refl_b02\")\n    b3 = img.select(\"sur_refl_b03\")\n    b4 = img.select(\"sur_refl_b04\")\n    b5 = img.select(\"sur_refl_b05\")\n    b6 = img.select(\"sur_refl_b06\")\n    b7 = img.select(\"sur_refl_b07\")\n\n    # single band thresholds\n    s1 = b1.gt(0.29)\n    s2 = b3.gt(0.23)\n    s3 = b4.gt(0.24)\n\n    # multi-band thresholds\n    m1 = b1.gt(0.28).And(b5.gt(0.24))\n    m2 = b1.gt(0.28).And(b6.gt(0.16))\n    m3 = b3.gt(0.28).And(b7.gt(0.08))\n\n    # band ratios\n    ratio = b2.divide(b1)\n    ratio_thresh = ratio.gt(0.95).And(ratio.lt(1.15))\n\n    # merge and average the results\n    stack = s1.addBands([s2, s3, m1, m2, m3, ratio_thresh])\n    probability = stack.reduce(ee.Reducer.mean())\n    mask = probability.lt(probability_threshold)\n\n    return img.updateMask(mask)\n</code></pre>"},{"location":"module/ThresholdMask/#earthlib.ThresholdMask.VIIRS","title":"<code>VIIRS(img, probability_threshold=0.4)</code>","text":"<p>Compute cloud probability using a series of band ratios and apply a mask threshold.</p> <p>See Sun &amp; Tian 2017: www.sciencedirect.com/science/article/pii/S0924271616306189</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to mask. Must have all the \"M*\" reflectance bands.</p> required <code>probability_threshold</code> <code>float</code> <p>pixels above this threshold are included in the mask.</p> <code>0.4</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>the same input image with an updated mask.</p> Source code in <code>earthlib/ThresholdMask.py</code> <pre><code>def VIIRS(img: ee.Image, probability_threshold: float = 0.4) -&gt; ee.Image:\n\"\"\"Compute cloud probability using a series of band ratios and apply a mask threshold.\n\n    See Sun &amp; Tian 2017: https://www.sciencedirect.com/science/article/pii/S0924271616306189\n\n    Args:\n        img: the ee.Image to mask. Must have all the \"M*\" reflectance bands.\n        probability_threshold: pixels above this threshold are included in the mask.\n\n    Returns:\n        the same input image with an updated mask.\n    \"\"\"\n    # band specifications\n    b1 = img.select(\"M1\")\n    b2 = img.select(\"M2\")\n    b3 = img.select(\"M3\")\n    b4 = img.select(\"M4\")\n    b5 = img.select(\"M5\")\n    b6 = img.select(\"M6\")\n    b7 = img.select(\"M7\")\n    b8 = img.select(\"M8\")\n\n    # single band thresholds\n    s1 = b1.gt(0.31)\n    s2 = b2.gt(0.25)\n    s3 = b3.gt(0.25)\n    s4 = b4.gt(0.25)\n    s5 = b5.gt(0.30)\n    s6 = b7.gt(0.52)\n    s7 = b8.gt(0.46)\n\n    # multi-band thresholds\n    m1 = b1.gt(0.29).And(b7.gt(0.30))\n    m2 = b1.gt(0.29).And(b8.gt(0.22))\n    m3 = b1.gt(0.31).And(b10.gt(0.08))\n    m4 = b1.gt(0.29).And(b11.gt(0.12))\n    m5 = b2.gt(0.27).And(b8.gt(0.22))\n    m6 = b2.gt(0.72).And(b10.gt(0.14))\n    m7 = b3.gt(0.23).And(b8.gt(0.24))\n    m8 = b3.gt(0.16).And(b9.gt(0.08))\n\n    # band ratios\n    ratio1 = b6.divide(b4)\n    ratio2 = b7.divide(b5)\n    ratio1_thresh = ratio1.gt(0.12).And(ratio1.lt(0.48))\n    ratio2_thresh = ratio2.gt(1.0).And(ratio2.lt(1.15))\n\n    # merge and average the results\n    stack = s1.addBands(\n        [\n            s2,\n            s3,\n            s4,\n            s5,\n            s6,\n            s7,\n            m1,\n            m2,\n            m3,\n            m4,\n            m5,\n            m6,\n            m7,\n            m8,\n            ratio1_thresh,\n            ratio2_thresh,\n        ]\n    )\n    probability = stack.reduce(ee.Reducer.mean())\n    mask = probability.lt(probability_threshold)\n\n    return img.updateMask(mask)\n</code></pre>"},{"location":"module/ThresholdMask/#earthlib.ThresholdMask.bySensor","title":"<code>bySensor(sensor)</code>","text":"<p>Returns the appropriate cloud mask function to use by sensor type.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the mask function associated with a sensor to pass to an ee .map() call</p> Source code in <code>earthlib/ThresholdMask.py</code> <pre><code>def bySensor(sensor: str) -&gt; Callable:\n\"\"\"Returns the appropriate cloud mask function to use by sensor type.\n\n    Args:\n        sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\").\n\n    Returns:\n        the mask function associated with a sensor to pass to an ee .map() call\n    \"\"\"\n    lookup = {\n        \"Landsat4\": Landsat457,\n        \"Landsat5\": Landsat457,\n        \"Landsat7\": Landsat457,\n        \"Landsat8\": Landsat8,\n        \"MODIS\": MODIS,\n        \"VIIRS\": VIIRS,\n    }\n    try:\n        function = lookup[sensor]\n        return function\n    except KeyError:\n        supported = \", \".join(lookup.keys())\n        raise SensorError(\n            f\"Cloud masking not supported for '{sensor}'. Supported: {supported}\"\n        )\n</code></pre>"},{"location":"module/Unmix/","title":"earthlib.Unmix","text":"<p>Routines for performing spectral unmixing on earth engine images.</p>"},{"location":"module/Unmix/#earthlib.Unmix.computeModeledSpectra","title":"<code>computeModeledSpectra(endmembers, fractions, n_bands)</code>","text":"<p>Constructs a modeled spectrum for each pixel based on endmember fractions.</p> <p>Parameters:</p> Name Type Description Default <code>endmembers</code> <code>list</code> <p>a list of ee.List() items, each representing an endmember spectrum.</p> required <code>fractions</code> <code>ee.Image</code> <p>ee.Image output from .unmix() with the same number of bands as items in <code>endmembers</code>.</p> required <code>n_bands</code> <code>int</code> <p>the number of reflectance bands used to compute the unmixing.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>an ee.Image with n_bands equal to the number of endmember bands.</p> Source code in <code>earthlib/Unmix.py</code> <pre><code>def computeModeledSpectra(\n    endmembers: list, fractions: ee.Image, n_bands: int\n) -&gt; ee.Image:\n\"\"\"Constructs a modeled spectrum for each pixel based on endmember fractions.\n\n    Args:\n        endmembers: a list of ee.List() items, each representing an endmember spectrum.\n        fractions: ee.Image output from .unmix() with the same number of bands as items in `endmembers`.\n        n_bands: the number of reflectance bands used to compute the unmixing.\n\n    Returns:\n        an ee.Image with n_bands equal to the number of endmember bands.\n    \"\"\"\n    # compute the number of endmember bands\n    band_range = list(range(n_bands))\n    band_names = [f\"M{band:02d}\" for band in band_range]\n\n    # create a list to store each reflectance fraction\n    refl_fraction_images = list()\n\n    # loop through each endmember and mulitply the fraction estimated by the reflectance value\n    for i, endmember in enumerate(endmembers):\n        fraction = fractions.select([i])\n        refl_fraction_list = [\n            fraction.multiply(ee.Number(endmember.get(band))) for band in band_range\n        ]\n        refl_fraction_images.append(\n            ee.ImageCollection.fromImages(refl_fraction_list)\n            .toBands()\n            .select(band_range, band_names)\n        )\n\n    # convert these images to an image collection and sum them together to reconstruct the spectrum\n    modeled_reflectance = (\n        ee.ImageCollection.fromImages(refl_fraction_images)\n        .sum()\n        .select(band_range, band_names)\n    )\n\n    return modeled_reflectance\n</code></pre>"},{"location":"module/Unmix/#earthlib.Unmix.computeSpectralRMSE","title":"<code>computeSpectralRMSE(measured, modeled, n_bands)</code>","text":"<p>Computes root mean squared error between measured and modeled spectra.</p> <p>Parameters:</p> Name Type Description Default <code>measured</code> <code>ee.Image</code> <p>an ee.Image of measured reflectance.</p> required <code>modeled</code> <code>ee.Image</code> <p>an ee.Image of modeled reflectance.</p> required <code>n_bands</code> <code>int</code> <p>the number of reflectance bands used to compute the unmixing.</p> required <p>Returns:</p> Name Type Description <code>rmse</code> <code>ee.Image</code> <p>a floating point ee.Image with pixel-wise RMSE values.</p> Source code in <code>earthlib/Unmix.py</code> <pre><code>def computeSpectralRMSE(\n    measured: ee.Image, modeled: ee.Image, n_bands: int\n) -&gt; ee.Image:\n\"\"\"Computes root mean squared error between measured and modeled spectra.\n\n    Args:\n        measured: an ee.Image of measured reflectance.\n        modeled: an ee.Image of modeled reflectance.\n        n_bands: the number of reflectance bands used to compute the unmixing.\n\n    Returns:\n        rmse: a floating point ee.Image with pixel-wise RMSE values.\n    \"\"\"\n    # harmonize band info to ensure element-wise computation\n    band_range = list(range(n_bands))\n    band_names = [f\"M{band:02d}\" for band in band_range]\n\n    # compute rmse\n    rmse = (\n        measured.select(band_range, band_names)\n        .subtract(modeled.select(band_range, band_names))\n        .pow(2)\n        .reduce(ee.Reducer.sum())\n        .sqrt()\n        .select([0], [RMSE])\n    )\n\n    return rmse\n</code></pre>"},{"location":"module/Unmix/#earthlib.Unmix.computeWeight","title":"<code>computeWeight(fractions, rmse_sum)</code>","text":"<p>Computes the relative weight for an image's RMSE based on the sum of the global RMSE.</p> <p>Parameters:</p> Name Type Description Default <code>fractions</code> <code>ee.Image</code> <p>a multi-band ee.Image object with an 'RMSE' band.</p> required <code>rmse_sum</code> <code>ee.Image</code> <p>a single-band ee.Image object with the global RMSE value.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>the input <code>fractions</code> image with a 'weight' band added.</p> Source code in <code>earthlib/Unmix.py</code> <pre><code>def computeWeight(fractions: ee.Image, rmse_sum: ee.Image) -&gt; ee.Image:\n\"\"\"Computes the relative weight for an image's RMSE based on the sum of the global RMSE.\n\n    Args:\n        fractions: a multi-band ee.Image object with an 'RMSE' band.\n        rmse_sum: a single-band ee.Image object with the global RMSE value.\n\n    Returns:\n        the input `fractions` image with a 'weight' band added.\n    \"\"\"\n    rmse = fractions.select([RMSE])\n    ratio = rmse.divide(rmse_sum).select([0], [\"ratio\"])\n    weight = ee.Image(1).subtract(ratio).select([0], [WEIGHT])\n    unweighted = fractions.addBands([weight])\n\n    return unweighted\n</code></pre>"},{"location":"module/Unmix/#earthlib.Unmix.fractionalCover","title":"<code>fractionalCover(img, endmembers, endmember_names, n_bands=None, shade_normalize=True)</code>","text":"<p>Computes the percent cover of each endmember spectra.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>the ee.Image to unmix.</p> required <code>endmembers</code> <code>list</code> <p>lists of ee.List objects, each element corresponding to a subType.</p> required <code>endmember_names</code> <code>list</code> <p>list of names for each endmember. must match the number of lists passed.</p> required <code>n_bands</code> <code>int</code> <p>number of reflectance bands used for unmixing.</p> <code>None</code> <code>shade_normalize</code> <code>bool</code> <p>flag to apply shade normalization during unmixing.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>unmixed</code> <code>ee.Image</code> <p>a 3-band image file in order of (soil-veg-impervious).</p> Source code in <code>earthlib/Unmix.py</code> <pre><code>def fractionalCover(\n    img: ee.Image,\n    endmembers: list,\n    endmember_names: list,\n    n_bands: int = None,\n    shade_normalize: bool = True,\n) -&gt; ee.Image:\n\"\"\"Computes the percent cover of each endmember spectra.\n\n    Args:\n        img: the ee.Image to unmix.\n        endmembers: lists of ee.List objects, each element corresponding to a subType.\n        endmember_names: list of names for each endmember. must match the number of lists passed.\n        n_bands: number of reflectance bands used for unmixing.\n        shade_normalize: flag to apply shade normalization during unmixing.\n\n    Returns:\n        unmixed: a 3-band image file in order of (soil-veg-impervious).\n    \"\"\"\n    if n_bands is None:\n        n_bands = len(list(img.bandNames().getInfo()))\n    n_classes = len(endmembers)\n    band_numbers = list(range(n_classes))\n    shade = ee.List([0] * n_bands)\n\n    # create a list of images to append and later convert to an image collection\n    unmixed = list()\n\n    # loop through each iteration and unmix each\n    for spectra in zip(*endmembers):\n\n        if shade_normalize:\n            spectra += (shade,)\n\n        unmixed_iter = img.unmix(spectra, True, True)\n\n        # run the forward model to evaluate the fractional cover fit\n        modeled_reflectance = computeModeledSpectra(spectra, unmixed_iter, n_bands)\n        rmse = computeSpectralRMSE(img, modeled_reflectance, n_bands)\n\n        # normalize by the observed shade fraction\n        if shade_normalize:\n            shade_fraction = unmixed_iter.select([n_classes]).subtract(1).abs()\n            unmixed_iter = unmixed_iter.divide(shade_fraction)\n\n        # rename the bands and append an rmse band\n        unmixed.append(\n            unmixed_iter.select(band_numbers, endmember_names).addBands(rmse)\n        )\n\n    # use the sum of rmse to weight each estimate\n    rmse_sum = ee.Image(\n        ee.ImageCollection.fromImages(unmixed).select([RMSE]).sum().select([0], [\"SUM\"])\n    )\n    unscaled = [computeWeight(fractions, rmse_sum) for fractions in unmixed]\n\n    # use these weights to scale each unmixing estimate\n    weight_sum = ee.Image(\n        ee.ImageCollection.fromImages(unscaled).select([WEIGHT]).sum()\n    )\n    scaled = [\n        weightedAverage(fractions, weight_sum, endmember_names)\n        for fractions in unscaled\n    ]\n\n    # reduce it to a single image and return\n    unmixed = ee.ImageCollection.fromImages(scaled).sum().toFloat()\n\n    return unmixed\n</code></pre>"},{"location":"module/Unmix/#earthlib.Unmix.weightedAverage","title":"<code>weightedAverage(fractions, weight_sum, band_names)</code>","text":"<p>Computes an RMSE-weighted fractional cover image.</p> <p>Parameters:</p> Name Type Description Default <code>fractions</code> <code>ee.Image</code> <p>a multi-band ee.Image object with a 'weight' band.</p> required <code>weight_sum</code> <code>ee.Image</code> <p>a single-band ee.Image object with the global weight sum.</p> required <code>band_names</code> <code>list</code> <p>list of band names to apply the weighted average to</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>a scaled fractional cover image.</p> Source code in <code>earthlib/Unmix.py</code> <pre><code>def weightedAverage(\n    fractions: ee.Image, weight_sum: ee.Image, band_names: list\n) -&gt; ee.Image:\n\"\"\"Computes an RMSE-weighted fractional cover image.\n\n    Args:\n        fractions: a multi-band ee.Image object with a 'weight' band.\n        weight_sum: a single-band ee.Image object with the global weight sum.\n        band_names: list of band names to apply the weighted average to\n\n    Returns:\n        a scaled fractional cover image.\n    \"\"\"\n    # harmonize band info\n    band_range = list(range(len(band_names)))\n\n    scaler = fractions.select([WEIGHT]).divide(weight_sum)\n    weighted = fractions.select(band_range, band_names).multiply(scaler)\n\n    return weighted\n</code></pre>"},{"location":"module/read/","title":"earthlib.read","text":"<p>Functions for reading specifically formatted data, mostly spectral libraries.</p>"},{"location":"module/read/#earthlib.read.Spectra","title":"<code>Spectra</code>","text":"<p>Class for storing one or more reference spectra</p> <p>Attributes:</p> Name Type Description <code>band_centers</code> <code>np.array</code> <p>center wavelength for each band</p> <code>band_quantity</code> <code>str</code> <p>the quantity measured for each band</p> <code>band_unit</code> <code>str</code> <p>the unit of measurement (micrometers or nanometers)</p> <code>names</code> <code>list</code> <p>list of reference names for each spectra</p> <code>spectra</code> <code>np.array</code> <p>array of numerical spectral data</p> Source code in <code>earthlib/read.py</code> <pre><code>class Spectra:\n\"\"\"Class for storing one or more reference spectra\n\n    Attributes:\n        band_centers: center wavelength for each band\n        band_quantity: the quantity measured for each band\n        band_unit: the unit of measurement (micrometers or nanometers)\n        names: list of reference names for each spectra\n        spectra: array of numerical spectral data\n    \"\"\"\n\n    band_centers: np.array\n    band_quantity: str\n    band_unit: str\n    names: list\n    spectra: np.array\n\n    def __init__(\n        self,\n        data: np.ndarray = None,\n        names: list = None,\n        n_spectra: int = 1,\n        n_wavelengths: int = 2151,\n        instrument: str = None,\n        band_centers: np.ndarray = None,\n        band_quantity: str = \"Wavelength\",\n        band_unit: str = \"Nanometers\",\n    ):\n\"\"\"Read, store and write spectral data.\n\n        Args:\n            data: an array of spectral responses\n                should be of shape (n_spectra, n_wavelengths)\n            names: list of names to assign to each spectra\n            n_spectra: the number of spectra included in the library\n                this and n_wavelengths are ignored if `data` is passed\n            n_wavelengths: the number of wavelengths for each spectrum\n            instrument: the spectroradiometer name\n            band_centers: the center wavelength for each band\n            band_quantity: the quantity measured by each band\n            band_unit: the unit of measurement (typically micrometers or nanometers)\n        \"\"\"\n        # get shape parameters from the data itself\n        if data is None:\n            data = np.zeros([n_spectra, n_wavelengths])\n        else:\n            n_spectra, n_wavelengths = data.shape\n\n        # set to asd type if no params set to change n_wl\n        if n_wavelengths == 2151:\n            instrument = \"asd\"\n\n        # set up pre-defined types\n        if instrument is not None:\n            if instrument.lower() == \"asd\":\n                n_wavelengths = 2151\n                band_unit = \"Nanometers\"\n                band_quantity = \"Wavelength\"\n                band_centers = np.arange(350, 2501)\n\n        # return a list same size as number of spectra\n        if names is None:\n            names = [f\"Spectrum {i}\" for i in range(n_spectra)]\n\n        # store the outputs\n        self.band_centers = band_centers\n        self.band_quantity = band_quantity\n        self.band_unit = band_unit\n        self.names = names\n        self.spectra = data\n\n    def remove_water_bands(self, set_nan: bool = False) -&gt; None:\n\"\"\"Sets reflectance data from water absorption bands to eithr 0 or NaN.\n\n        Wavelengths in the ranges of (1.35-1.46 um and 1.79-1.96 um) will be masked.\n            Updates the self.spectra array in-place.\n\n        Args:\n            set_nan: set the water bands to NaN. False sets values to 0.\n        \"\"\"\n\n        if set_nan:\n            update_val = np.nan\n        else:\n            update_val = 0\n\n        if self.band_unit.lower() == \"micrometers\":\n            water_bands = [[1.35, 1.46], [1.79, 1.96]]\n        else:\n            water_bands = [[1350.0, 1460.0], [1790.0, 1960.0]]\n\n        # start with nir-swir1 transition\n        gt = np.where(self.band_centers &gt; water_bands[0][0])\n        lt = np.where(self.band_centers &lt; water_bands[0][1])\n        nd = np.intersect1d(gt[0], lt[0])\n        self.spectra[:, nd] = update_val\n        self.band_centers = np.delete(self.band_centers, nd)\n\n        # then swir1-swir2 transition\n        gt = np.where(self.band_centers &gt; water_bands[1][0])\n        lt = np.where(self.band_centers &lt; water_bands[1][1])\n        nd = np.intersect1d(gt[0], lt[0])\n        self.spectra[:, nd] = update_val\n        self.band_centers = np.delete(self.band_centers, nd)\n\n    def get_shortwave_bands(self) -&gt; np.ndarray:\n\"\"\"Returns indices of the bands that encompass the shortwave range.\n\n        This refers to the range (350 - 2500 nm).\n\n        Returns:\n            an index of bands to subset to the shortwave range.\n        \"\"\"\n\n        # set range to return in nanometers\n        shortwave_range = [350.0, 2500.0]\n\n        # normalize if wavelength units are different\n        if self.band_unit.lower() == \"micrometers\":\n            shortwave_range /= 1000.0\n\n        # find overlapping range\n        gt = np.where(self.band_centers &gt; shortwave_range[0])\n        lt = np.where(self.band_centers &lt; shortwave_range[1])\n        overlap = np.intersect1d(gt[0], lt[0])\n\n        # return output\n        return overlap\n\n    def bn(self, inds: list = None) -&gt; None:\n\"\"\"Brightness normalizes the spectra.\n\n        Updates the self.spectra array in-place.\n\n        Args:\n            inds: the band indices to use for normalization.\n        \"\"\"\n        # check if indices were set and valid. if not, use all bands\n        if inds:\n            if max(inds) &gt; self.spectra.shape[-1]:\n                inds = range(0, self.spectra.shape[-1])\n                warn(\"Invalid range set. using all spectra\")\n\n            if min(inds) &lt; 0:\n                inds = range(0, self.spectra.shape[-1])\n                warn(\"Invalid range set. using all spectra\")\n\n        else:\n            inds = range(0, self.spectra.shape[-1])\n\n        # perform the bn\n        self.spectra = self.spectra[:, inds] / np.expand_dims(\n            np.sqrt((self.spectra[:, inds] ** 2).sum(1)), 1\n        )\n\n        # subset band centers to the indices selected, if they exist\n        if self.band_centers.ndim != 0:\n            self.band_centers = self.band_centers[inds]\n\n    def write_sli(\n        self, path: str, row_inds: list = None, spectral_inds: list = None\n    ) -&gt; None:\n\"\"\"Writes the spectral object to an ENVI spectral library file.\n\n        Args:\n            path: the output file to write the array to.\n            row_inds: the row-wise indices of the array to write.\n            spectral_inds: indices for which spectral to write\n        \"\"\"\n\n        # set up the output file names for the library and the header\n        base, ext = os.path.splitext(path)\n        if ext.lower() == \".sli\":\n            osli = path\n            ohdr = \"{}.hdr\".format(base)\n        elif ext.lower() == \".hdr\":\n            osli = \"{}.hdr\".format(base)\n            ohdr = path\n        else:\n            osli = \"{}.sli\".format(base)\n            ohdr = \"{}.hdr\".format(base)\n\n        # subset the data if specific indices are set\n        spectra = self.spectra\n        names = self.names\n        band_centers = self.band_centers\n\n        if row_inds is not None:\n            spectra = spectra[row_inds, :]\n            names = np.array(names)[row_inds]\n\n        if spectral_inds is not None:\n            spectra = spectra[:, spectral_inds]\n            band_centers = band_centers[spectral_inds]\n\n        # set up the metadata for the ENVI header file\n        metadata = {\n            \"samples\": len(band_centers),\n            \"lines\": len(names),\n            \"bands\": 1,\n            \"data type\": 4,\n            \"header offset\": 0,\n            \"interleave\": \"bsq\",\n            \"byte order\": 0,\n            \"sensor type\": \"earthlib\",\n            \"spectra names\": names,\n            \"wavelength units\": self.band_unit,\n            \"wavelength\": band_centers,\n        }\n        spectral.envi.write_envi_header(ohdr, metadata, is_library=True)\n\n        # then write the spectral library\n        with open(osli, \"w\") as f:\n            spectra.astype(np.float32).tofile(f)\n</code></pre>"},{"location":"module/read/#earthlib.read.Spectra.__init__","title":"<code>__init__(data=None, names=None, n_spectra=1, n_wavelengths=2151, instrument=None, band_centers=None, band_quantity='Wavelength', band_unit='Nanometers')</code>","text":"<p>Read, store and write spectral data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>an array of spectral responses should be of shape (n_spectra, n_wavelengths)</p> <code>None</code> <code>names</code> <code>list</code> <p>list of names to assign to each spectra</p> <code>None</code> <code>n_spectra</code> <code>int</code> <p>the number of spectra included in the library this and n_wavelengths are ignored if <code>data</code> is passed</p> <code>1</code> <code>n_wavelengths</code> <code>int</code> <p>the number of wavelengths for each spectrum</p> <code>2151</code> <code>instrument</code> <code>str</code> <p>the spectroradiometer name</p> <code>None</code> <code>band_centers</code> <code>np.ndarray</code> <p>the center wavelength for each band</p> <code>None</code> <code>band_quantity</code> <code>str</code> <p>the quantity measured by each band</p> <code>'Wavelength'</code> <code>band_unit</code> <code>str</code> <p>the unit of measurement (typically micrometers or nanometers)</p> <code>'Nanometers'</code> Source code in <code>earthlib/read.py</code> <pre><code>def __init__(\n    self,\n    data: np.ndarray = None,\n    names: list = None,\n    n_spectra: int = 1,\n    n_wavelengths: int = 2151,\n    instrument: str = None,\n    band_centers: np.ndarray = None,\n    band_quantity: str = \"Wavelength\",\n    band_unit: str = \"Nanometers\",\n):\n\"\"\"Read, store and write spectral data.\n\n    Args:\n        data: an array of spectral responses\n            should be of shape (n_spectra, n_wavelengths)\n        names: list of names to assign to each spectra\n        n_spectra: the number of spectra included in the library\n            this and n_wavelengths are ignored if `data` is passed\n        n_wavelengths: the number of wavelengths for each spectrum\n        instrument: the spectroradiometer name\n        band_centers: the center wavelength for each band\n        band_quantity: the quantity measured by each band\n        band_unit: the unit of measurement (typically micrometers or nanometers)\n    \"\"\"\n    # get shape parameters from the data itself\n    if data is None:\n        data = np.zeros([n_spectra, n_wavelengths])\n    else:\n        n_spectra, n_wavelengths = data.shape\n\n    # set to asd type if no params set to change n_wl\n    if n_wavelengths == 2151:\n        instrument = \"asd\"\n\n    # set up pre-defined types\n    if instrument is not None:\n        if instrument.lower() == \"asd\":\n            n_wavelengths = 2151\n            band_unit = \"Nanometers\"\n            band_quantity = \"Wavelength\"\n            band_centers = np.arange(350, 2501)\n\n    # return a list same size as number of spectra\n    if names is None:\n        names = [f\"Spectrum {i}\" for i in range(n_spectra)]\n\n    # store the outputs\n    self.band_centers = band_centers\n    self.band_quantity = band_quantity\n    self.band_unit = band_unit\n    self.names = names\n    self.spectra = data\n</code></pre>"},{"location":"module/read/#earthlib.read.Spectra.bn","title":"<code>bn(inds=None)</code>","text":"<p>Brightness normalizes the spectra.</p> <p>Updates the self.spectra array in-place.</p> <p>Parameters:</p> Name Type Description Default <code>inds</code> <code>list</code> <p>the band indices to use for normalization.</p> <code>None</code> Source code in <code>earthlib/read.py</code> <pre><code>def bn(self, inds: list = None) -&gt; None:\n\"\"\"Brightness normalizes the spectra.\n\n    Updates the self.spectra array in-place.\n\n    Args:\n        inds: the band indices to use for normalization.\n    \"\"\"\n    # check if indices were set and valid. if not, use all bands\n    if inds:\n        if max(inds) &gt; self.spectra.shape[-1]:\n            inds = range(0, self.spectra.shape[-1])\n            warn(\"Invalid range set. using all spectra\")\n\n        if min(inds) &lt; 0:\n            inds = range(0, self.spectra.shape[-1])\n            warn(\"Invalid range set. using all spectra\")\n\n    else:\n        inds = range(0, self.spectra.shape[-1])\n\n    # perform the bn\n    self.spectra = self.spectra[:, inds] / np.expand_dims(\n        np.sqrt((self.spectra[:, inds] ** 2).sum(1)), 1\n    )\n\n    # subset band centers to the indices selected, if they exist\n    if self.band_centers.ndim != 0:\n        self.band_centers = self.band_centers[inds]\n</code></pre>"},{"location":"module/read/#earthlib.read.Spectra.get_shortwave_bands","title":"<code>get_shortwave_bands()</code>","text":"<p>Returns indices of the bands that encompass the shortwave range.</p> <p>This refers to the range (350 - 2500 nm).</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>an index of bands to subset to the shortwave range.</p> Source code in <code>earthlib/read.py</code> <pre><code>def get_shortwave_bands(self) -&gt; np.ndarray:\n\"\"\"Returns indices of the bands that encompass the shortwave range.\n\n    This refers to the range (350 - 2500 nm).\n\n    Returns:\n        an index of bands to subset to the shortwave range.\n    \"\"\"\n\n    # set range to return in nanometers\n    shortwave_range = [350.0, 2500.0]\n\n    # normalize if wavelength units are different\n    if self.band_unit.lower() == \"micrometers\":\n        shortwave_range /= 1000.0\n\n    # find overlapping range\n    gt = np.where(self.band_centers &gt; shortwave_range[0])\n    lt = np.where(self.band_centers &lt; shortwave_range[1])\n    overlap = np.intersect1d(gt[0], lt[0])\n\n    # return output\n    return overlap\n</code></pre>"},{"location":"module/read/#earthlib.read.Spectra.remove_water_bands","title":"<code>remove_water_bands(set_nan=False)</code>","text":"<p>Sets reflectance data from water absorption bands to eithr 0 or NaN.</p> <p>Wavelengths in the ranges of (1.35-1.46 um and 1.79-1.96 um) will be masked.     Updates the self.spectra array in-place.</p> <p>Parameters:</p> Name Type Description Default <code>set_nan</code> <code>bool</code> <p>set the water bands to NaN. False sets values to 0.</p> <code>False</code> Source code in <code>earthlib/read.py</code> <pre><code>def remove_water_bands(self, set_nan: bool = False) -&gt; None:\n\"\"\"Sets reflectance data from water absorption bands to eithr 0 or NaN.\n\n    Wavelengths in the ranges of (1.35-1.46 um and 1.79-1.96 um) will be masked.\n        Updates the self.spectra array in-place.\n\n    Args:\n        set_nan: set the water bands to NaN. False sets values to 0.\n    \"\"\"\n\n    if set_nan:\n        update_val = np.nan\n    else:\n        update_val = 0\n\n    if self.band_unit.lower() == \"micrometers\":\n        water_bands = [[1.35, 1.46], [1.79, 1.96]]\n    else:\n        water_bands = [[1350.0, 1460.0], [1790.0, 1960.0]]\n\n    # start with nir-swir1 transition\n    gt = np.where(self.band_centers &gt; water_bands[0][0])\n    lt = np.where(self.band_centers &lt; water_bands[0][1])\n    nd = np.intersect1d(gt[0], lt[0])\n    self.spectra[:, nd] = update_val\n    self.band_centers = np.delete(self.band_centers, nd)\n\n    # then swir1-swir2 transition\n    gt = np.where(self.band_centers &gt; water_bands[1][0])\n    lt = np.where(self.band_centers &lt; water_bands[1][1])\n    nd = np.intersect1d(gt[0], lt[0])\n    self.spectra[:, nd] = update_val\n    self.band_centers = np.delete(self.band_centers, nd)\n</code></pre>"},{"location":"module/read/#earthlib.read.Spectra.write_sli","title":"<code>write_sli(path, row_inds=None, spectral_inds=None)</code>","text":"<p>Writes the spectral object to an ENVI spectral library file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the output file to write the array to.</p> required <code>row_inds</code> <code>list</code> <p>the row-wise indices of the array to write.</p> <code>None</code> <code>spectral_inds</code> <code>list</code> <p>indices for which spectral to write</p> <code>None</code> Source code in <code>earthlib/read.py</code> <pre><code>def write_sli(\n    self, path: str, row_inds: list = None, spectral_inds: list = None\n) -&gt; None:\n\"\"\"Writes the spectral object to an ENVI spectral library file.\n\n    Args:\n        path: the output file to write the array to.\n        row_inds: the row-wise indices of the array to write.\n        spectral_inds: indices for which spectral to write\n    \"\"\"\n\n    # set up the output file names for the library and the header\n    base, ext = os.path.splitext(path)\n    if ext.lower() == \".sli\":\n        osli = path\n        ohdr = \"{}.hdr\".format(base)\n    elif ext.lower() == \".hdr\":\n        osli = \"{}.hdr\".format(base)\n        ohdr = path\n    else:\n        osli = \"{}.sli\".format(base)\n        ohdr = \"{}.hdr\".format(base)\n\n    # subset the data if specific indices are set\n    spectra = self.spectra\n    names = self.names\n    band_centers = self.band_centers\n\n    if row_inds is not None:\n        spectra = spectra[row_inds, :]\n        names = np.array(names)[row_inds]\n\n    if spectral_inds is not None:\n        spectra = spectra[:, spectral_inds]\n        band_centers = band_centers[spectral_inds]\n\n    # set up the metadata for the ENVI header file\n    metadata = {\n        \"samples\": len(band_centers),\n        \"lines\": len(names),\n        \"bands\": 1,\n        \"data type\": 4,\n        \"header offset\": 0,\n        \"interleave\": \"bsq\",\n        \"byte order\": 0,\n        \"sensor type\": \"earthlib\",\n        \"spectra names\": names,\n        \"wavelength units\": self.band_unit,\n        \"wavelength\": band_centers,\n    }\n    spectral.envi.write_envi_header(ohdr, metadata, is_library=True)\n\n    # then write the spectral library\n    with open(osli, \"w\") as f:\n        spectra.astype(np.float32).tofile(f)\n</code></pre>"},{"location":"module/read/#earthlib.read.check_file","title":"<code>check_file(path)</code>","text":"<p>Verifies whether a file exists and can be read.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the file path to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>file status.</p> Source code in <code>earthlib/read.py</code> <pre><code>def check_file(path: str) -&gt; bool:\n\"\"\"Verifies whether a file exists and can be read.\n\n    Args:\n        path: the file path to check.\n\n    Returns:\n        file status.\n    \"\"\"\n    return os.path.isfile(path) and os.access(path, os.R_OK)\n</code></pre>"},{"location":"module/read/#earthlib.read.endmembers","title":"<code>endmembers()</code>","text":"<p>Reads the earthlib spectral endmember library into memory.</p> <p>Returns:</p> Type Description <code>Spectra</code> <p>an earthlib Spectra class with the endmember library reflectance data.</p> Source code in <code>earthlib/read.py</code> <pre><code>def endmembers() -&gt; Spectra:\n\"\"\"Reads the earthlib spectral endmember library into memory.\n\n    Returns:\n        an earthlib Spectra class with the endmember library reflectance data.\n    \"\"\"\n    return spectralLibrary(endmember_path)\n</code></pre>"},{"location":"module/read/#earthlib.read.jfsp","title":"<code>jfsp(path)</code>","text":"<p>Reads JFSP-formatted ASCII files.</p> <p>Reads the ASCII format spectral data from the joint-fire-science-program     and returns an object with the mean and \u00b1 standard deviation reflectance.     www.frames.gov/assessing-burn-severity/spectral-library/overview</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>file path to the JFSP spectra text file.</p> required <p>Returns:</p> Type Description <code>Spectra</code> <p>an earthlib Spectra with the JFSP reflectance data.</p> Source code in <code>earthlib/read.py</code> <pre><code>def jfsp(path: str) -&gt; Spectra:\n\"\"\"Reads JFSP-formatted ASCII files.\n\n    Reads the ASCII format spectral data from the joint-fire-science-program\n        and returns an object with the mean and +/- standard deviation reflectance.\n        https://www.frames.gov/assessing-burn-severity/spectral-library/overview\n\n    Args:\n        path: file path to the JFSP spectra text file.\n\n    Returns:\n        an earthlib Spectra with the JFSP reflectance data.\n    \"\"\"\n\n    # create the spectral object\n    s = spectralObject(n_spectra=1, instrument=\"asd\")\n    s.spectra_stdevm = np.zeros(s.spectra.shape)\n    s.spectra_stdevp = np.zeros(s.spectra.shape)\n\n    # open the file and read the data\n    with open(path, \"r\") as f:\n        f.readline()\n        for i, line in enumerate(f):\n            line = line.strip().split()\n            s.spectra[0, i] = line[1]\n            s.spectra_stdevp[0, i] = line[2]\n            s.spectra_stdevm[0, i] = line[3]\n\n        return s\n</code></pre>"},{"location":"module/read/#earthlib.read.spectralLibrary","title":"<code>spectralLibrary(path)</code>","text":"<p>Reads an ENVI-format spectral library into memory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>file path to the ENVI spectral library file. Looks for a .hdr sidecar file.</p> required <p>Returns:</p> Type Description <code>Spectra</code> <p>an earthlib Spectra with the spectral library data.</p> Source code in <code>earthlib/read.py</code> <pre><code>def spectralLibrary(path: str) -&gt; Spectra:\n\"\"\"Reads an ENVI-format spectral library into memory.\n\n    Args:\n        path: file path to the ENVI spectral library file. Looks for a .hdr sidecar file.\n\n    Returns:\n        an earthlib Spectra with the spectral library data.\n    \"\"\"\n\n    # get the header file path\n    if check_file(path[:-4] + \".hdr\"):\n        hdr = path[:-4] + \".hdr\"\n    else:\n        if check_file(path + \".hdr\"):\n            hdr = path + \".hdr\"\n        else:\n            return None\n\n    slib = spectral.envi.open(hdr, path)\n    s = Spectra(\n        data=slib.spectra,\n        names=slib.names,\n        band_centers=np.asarray(slib.bands.centers),\n        band_unit=slib.bands.band_unit,\n        band_quantity=slib.bands.band_quantity,\n    )\n\n    return s\n</code></pre>"},{"location":"module/read/#earthlib.read.usgs","title":"<code>usgs(path)</code>","text":"<p>Reads USGS-formatted ASCII files.</p> <p>Reads ascii spectral data from USGS-format files and returns     the mean and \u00b1 standard deviation.     www.sciencebase.gov/catalog/item/5807a2a2e4b0841e59e3a18d</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>file path the the USGS spectra text file.</p> required <p>Returns:</p> Type Description <code>Spectra</code> <p>an earthlib Spectra with the USGS reflectance data.</p> Source code in <code>earthlib/read.py</code> <pre><code>def usgs(path: str) -&gt; Spectra:\n\"\"\"Reads USGS-formatted ASCII files.\n\n    Reads ascii spectral data from USGS-format files and returns\n        the mean and +/- standard deviation.\n        https://www.sciencebase.gov/catalog/item/5807a2a2e4b0841e59e3a18d\n\n    Args:\n        path: file path the the USGS spectra text file.\n\n    Returns:\n        an earthlib Spectra with the USGS reflectance data.\n    \"\"\"\n\n    # open the file and read header info\n    with open(path, \"r\") as f:\n        x_start = \"gibberish\"\n        for line in f:\n            if x_start in line:\n                break\n            if \"Name:\" in line:\n                spectrum_name = line.strip().split(\"Name:\")[-1].strip()\n            if \"X Units:\" in line:\n                band_unit = line.strip().split()\n                band_unit = band_unit[-1].strip(\"()\").capitalize()\n            if \"Y Units:\" in line:\n                refl_unit = line.strip().split()\n                refl_unit = refl_unit[-1].strip(\"()\").capitalize()\n            if \"First X Value:\" in line:\n                x_start = line.strip().split()[-1]\n            if \"Number of X Values:\" in line:\n                n_values = int(line.strip().split()[-1])\n\n        # now that we got our header info, create the arrays\n        band_centers = np.empty(n_values)\n        reflectance = np.empty(n_values)\n\n        line = line.strip().split()\n        band_centers[0] = float(line[0])\n        reflectance[0] = float(line[1])\n\n        # resume reading through file\n        i = 1\n        for line in f:\n            line = line.strip().split()\n            band_centers[i] = float(line[0])\n            reflectance[i] = float(line[1])\n            i += 1\n\n        # some files read last -&gt; first wavelength\n        if band_centers[0] &gt; band_centers[-1]:\n            band_centers = band_centers[::-1]\n            reflectance = reflectance[::1]\n\n        # convert units to nanometers and scale 0-1\n        if band_unit.lower() == \"micrometers\":\n            band_centers *= 1000.0\n            band_unit = \"Nanometers\"\n\n        if refl_unit.lower() == \"percent\":\n            reflectance /= 100.0\n\n        # create the spectral object\n        s = Spectra(\n            n_spectra=1,\n            n_wavelengths=n_values,\n            band_centers=band_centers,\n            band_unit=band_unit,\n            band_quantity=\"Wavelength\",\n        )\n\n        # assign relevant values\n        s.spectra[0] = reflectance\n        if spectrum_name:\n            s.names[0] = spectrum_name\n\n    return s\n</code></pre>"},{"location":"module/utils/","title":"earthlib.utils","text":"<p>Utility functions for working with spectral libraries and earth engine routines.</p>"},{"location":"module/utils/#earthlib.utils.getBandDescriptions","title":"<code>getBandDescriptions(sensor)</code>","text":"<p>Returns a list band name descriptions by sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>the name of the sensor (from earthlib.listSensors()).</p> required <p>Returns:</p> Name Type Description <code>bands</code> <code>list</code> <p>a list of sensor-specific band names.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def getBandDescriptions(sensor: str) -&gt; list:\n\"\"\"Returns a list band name descriptions by sensor.\n\n    Args:\n        sensor: the name of the sensor (from earthlib.listSensors()).\n\n    Returns:\n        bands: a list of sensor-specific band names.\n    \"\"\"\n    validateSensor(sensor)\n    bands = copy(collections[sensor]).get(\"band_descriptions\")\n    return bands\n</code></pre>"},{"location":"module/utils/#earthlib.utils.getBandIndices","title":"<code>getBandIndices(custom_bands, sensor)</code>","text":"<p>Cross-references a list of bands passed as strings to the 0-based integer indices</p> <p>Parameters:</p> Name Type Description Default <code>custom_bands</code> <code>list</code> <p>a list of band names.</p> required <code>sensor</code> <code>str</code> <p>a string sensor type for indexing the supported collections.</p> required <p>Returns:</p> Name Type Description <code>indices</code> <code>list</code> <p>list of integer band indices.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def getBandIndices(custom_bands: list, sensor: str) -&gt; list:\n\"\"\"Cross-references a list of bands passed as strings to the 0-based integer indices\n\n    Args:\n        custom_bands: a list of band names.\n        sensor: a string sensor type for indexing the supported collections.\n\n    Returns:\n        indices: list of integer band indices.\n    \"\"\"\n    validateSensor(sensor)\n    sensor_bands = getBands(sensor)\n    indices = list()\n\n    if type(custom_bands) in (list, tuple):\n        for band in custom_bands:\n            if band in sensor_bands:\n                indices.append(sensor_bands.index(band))\n\n    elif type(custom_bands) == str:\n        indices.append(sensor_bands.index(custom_bands))\n\n    indices.sort()\n    return indices\n</code></pre>"},{"location":"module/utils/#earthlib.utils.getBands","title":"<code>getBands(sensor)</code>","text":"<p>Returns a list of available band names by sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>the name of the sensor (from earthlib.listSensors()).</p> required <p>Returns:</p> Name Type Description <code>bands</code> <code>list</code> <p>a list of sensor-specific band names.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def getBands(sensor: str) -&gt; list:\n\"\"\"Returns a list of available band names by sensor.\n\n    Args:\n        sensor: the name of the sensor (from earthlib.listSensors()).\n\n    Returns:\n        bands: a list of sensor-specific band names.\n    \"\"\"\n    validateSensor(sensor)\n    bands = copy(collections[sensor]).get(\"band_names\")\n    return bands\n</code></pre>"},{"location":"module/utils/#earthlib.utils.getCollection","title":"<code>getCollection(sensor)</code>","text":"<p>Returns the default image collection for a satellite sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>the name of the sensor (from earthlib.listSensors()).</p> required <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>that sensor's ee image collection.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def getCollection(sensor: str) -&gt; ee.ImageCollection:\n\"\"\"Returns the default image collection for a satellite sensor.\n\n    Args:\n        sensor: the name of the sensor (from earthlib.listSensors()).\n\n    Returns:\n        that sensor's ee image collection.\n    \"\"\"\n    return ee.ImageCollection(getCollectionName(sensor))\n</code></pre>"},{"location":"module/utils/#earthlib.utils.getCollectionName","title":"<code>getCollectionName(sensor)</code>","text":"<p>Returns the earth engine collection name for a specific satellite sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>the name of the sensor (from earthlib.listSensors()).</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>str</code> <p>a string with the earth engine collection.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def getCollectionName(sensor: str) -&gt; str:\n\"\"\"Returns the earth engine collection name for a specific satellite sensor.\n\n    Args:\n        sensor: the name of the sensor (from earthlib.listSensors()).\n\n    Returns:\n        collection: a string with the earth engine collection.\n    \"\"\"\n    validateSensor(sensor)\n    collection = collections[sensor][\"collection\"]\n    return collection\n</code></pre>"},{"location":"module/utils/#earthlib.utils.getScaler","title":"<code>getScaler(sensor)</code>","text":"<p>Returns the scaling factor to convert sensor data to percent reflectance (0-1).</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>the name of the sensor (from earthlib.listSensors()).</p> required <p>Returns:</p> Name Type Description <code>scaler</code> <code>str</code> <p>the scale factor to multiply.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def getScaler(sensor: str) -&gt; str:\n\"\"\"Returns the scaling factor to convert sensor data to percent reflectance (0-1).\n\n    Args:\n        sensor: the name of the sensor (from earthlib.listSensors()).\n\n    Returns:\n        scaler: the scale factor to multiply.\n    \"\"\"\n    validateSensor(sensor)\n    scaler = copy(collections[sensor]).get(\"scale\")\n    return scaler\n</code></pre>"},{"location":"module/utils/#earthlib.utils.getTypeLevel","title":"<code>getTypeLevel(Type)</code>","text":"<p>Checks whether a spectral data type is available in the endmember library.</p> <p>Parameters:</p> Name Type Description Default <code>Type</code> <code>str</code> <p>the type of spectra to select.</p> required <p>Returns:</p> Name Type Description <code>level</code> <code>int</code> <p>the metadata \"level\" of the group for subsetting. returns 0 if not found.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def getTypeLevel(Type: str) -&gt; int:\n\"\"\"Checks whether a spectral data type is available in the endmember library.\n\n    Args:\n        Type: the type of spectra to select.\n\n    Returns:\n        level: the metadata \"level\" of the group for subsetting. returns 0 if not found.\n    \"\"\"\n    for i in range(4):\n        level = i + 1\n        available_types = listTypes(level=level)\n        if Type in available_types:\n            return level\n\n    return 0\n</code></pre>"},{"location":"module/utils/#earthlib.utils.listSensors","title":"<code>listSensors()</code>","text":"<p>Returns a list of the supported sensor image collections.</p> <p>Returns:</p> Name Type Description <code>sensors</code> <code>list</code> <p>a list of supported sensors using the names referenced by this package.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def listSensors() -&gt; list:\n\"\"\"Returns a list of the supported sensor image collections.\n\n    Returns:\n        sensors: a list of supported sensors using the names referenced by this package.\n    \"\"\"\n    sensors = list(collections.keys())\n    return sensors\n</code></pre>"},{"location":"module/utils/#earthlib.utils.listTypes","title":"<code>listTypes(level=2)</code>","text":"<p>Returns a list of the spectral classification types.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>the level of spectral classification specificity to return. Supports integers 1-4.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>classes</code> <code>list</code> <p>a list of spectral data types referenced throughout this package.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def listTypes(level: int = 2) -&gt; list:\n\"\"\"Returns a list of the spectral classification types.\n\n    Args:\n        level: the level of spectral classification specificity to return. Supports integers 1-4.\n\n    Returns:\n        classes: a list of spectral data types referenced throughout this package.\n    \"\"\"\n    key = f\"LEVEL_{level}\"\n    types = list(metadata[key].unique())\n    return types\n</code></pre>"},{"location":"module/utils/#earthlib.utils.selectSpectra","title":"<code>selectSpectra(Type, sensor, n=20, bands=None)</code>","text":"<p>Subsets the earthlib spectral endmember library.</p> <p>Selects endmembers from specific class, then resamples the spectra to the wavelengths of a specific satellite sensor. This also performs random spectra selection.</p> <p>Parameters:</p> Name Type Description Default <code>Type</code> <code>str</code> <p>the type of spectra to select (from earthlib.listTypes()).</p> required <code>sensor</code> <code>str</code> <p>the sensor type to resample wavelengths to.</p> required <code>n</code> <code>int</code> <p>the number of random spectra to sample. n=0 returns all spectra.</p> <code>20</code> <code>bands</code> <code>list</code> <p>list of bands to use. Accepts 0-based indices or a list of band names (e.g. [\"B2\", \"B3\", \"B4\"]).</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>a list of spectral endmembers resampled to a specific sensor's wavelengths.</p> Source code in <code>earthlib/utils.py</code> <pre><code>def selectSpectra(Type: str, sensor: str, n: int = 20, bands: list = None) -&gt; list:\n\"\"\"Subsets the earthlib spectral endmember library.\n\n    Selects endmembers from specific class, then resamples the spectra to the wavelengths\n    of a specific satellite sensor. This also performs random spectra selection.\n\n    Args:\n        Type: the type of spectra to select (from earthlib.listTypes()).\n        sensor: the sensor type to resample wavelengths to.\n        n: the number of random spectra to sample. n=0 returns all spectra.\n        bands: list of bands to use. Accepts 0-based indices or a list of band names (e.g. [\"B2\", \"B3\", \"B4\"]).\n\n    Returns:\n        a list of spectral endmembers resampled to a specific sensor's wavelengths.\n    \"\"\"\n    validateSensor(sensor)\n\n    # get the level of the group selected\n    level = getTypeLevel(Type)\n    if level == 0:\n        raise EndmemberError(\n            f\"Invalid group parameter: {Type}. Get valid values from earthlib.listTypes().\"\n        )\n\n    # read the spectral library into memory\n    endmembers = spectralLibrary(endmember_path)\n\n    # subset to specific bands, if set\n    if bands is None:\n        bands = range(len(getBands(sensor)))\n    else:\n        if type(bands[0]) is str:\n            bands = getBandIndices(bands, sensor)\n\n    # create a band resampler for this collection\n    sensor_centers = np.array(collections[sensor][\"band_centers\"])[bands]\n    sensor_fwhm = np.array(collections[sensor][\"band_widths\"])[bands]\n    resampler = spectral.BandResampler(\n        endmembers.band_centers, sensor_centers, fwhm2=sensor_fwhm\n    )\n\n    # select the endmembers from just the type passed\n    key = f\"LEVEL_{level}\"\n    indices = metadata[key] == Type\n    spectra_raw = endmembers.spectra[indices, :]\n\n    # subset them further if the n parameter is passed\n    if n &gt; 0:\n        random_indices = np.random.randint(indices.sum(), size=n)\n        spectra_raw = spectra_raw[random_indices, :]\n\n    # loop through each spectrum and resample to the sensor wavelengths\n    resampled = list()\n    for i in range(spectra_raw.shape[0]):\n        spectrum = resampler(spectra_raw[i, :])\n        resampled.append(spectrum)\n\n    return resampled\n</code></pre>"},{"location":"module/utils/#earthlib.utils.validateSensor","title":"<code>validateSensor(sensor)</code>","text":"<p>Verify a string sensor ID is valid, raise an error otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>the name of the sensor (from earthlib.listSensors()).</p> required <p>Raises:</p> Type Description <code>SensorError</code> <p>when an invalid sensor name is passed</p> Source code in <code>earthlib/utils.py</code> <pre><code>def validateSensor(sensor: str) -&gt; None:\n\"\"\"Verify a string sensor ID is valid, raise an error otherwise.\n\n    Args:\n        sensor: the name of the sensor (from earthlib.listSensors()).\n\n    Raises:\n        SensorError: when an invalid sensor name is passed\n    \"\"\"\n    supported = listSensors()\n    if sensor not in supported:\n        raise SensorError(\n            f\"Invalid sensor: {sensor}. Supported: {', '.join(supported)}\"\n        )\n</code></pre>"}]}